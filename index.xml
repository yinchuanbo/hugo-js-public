<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>灏天阁</title>
    <link>/</link>
    <description>Recent content on 灏天阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2008–2019, Steve Francia and the lee.so; all rights reserved.</copyright>
    <lastBuildDate>Sun, 03 Sep 2023 11:00:57 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>观察者模式</title>
      <link>/posts/29/</link>
      <pubDate>Sun, 03 Sep 2023 11:00:57 +0800</pubDate>
      
      <guid>/posts/29/</guid>
      <description>又被称为发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。
我们需要把观察者对象创建出来，他有一个消息容器，和三个方法，分别是订阅消息方法、取消订阅的消息方法、发送订阅消息的方法。
// 将观察者放在闭包中，当页面加载就立即执行 var Observer = (function () { // 防止消息队列暴漏而被篡改故将消息容器作为静态私有变量保存 var _messages = {}; return { // 注册信息接口 regist: function (type, fn) { // 如果消息不存在则应该创建一个该消息类型 if (typeof _messages[type] === &amp;#34;undefined&amp;#34;) { // 将动作推入到该消息对应的动作执行队列中 _messages[type] = [fn]; } else { // 如果信息存在 // 将动作方法推入该消息对应的动作执行序列中 _messages[type].push(fn); } }, // 发布信息接口 fire: function (type, args) { // 如果该消息没有被注册，则返回 if (!_messages[type]) { return; } // 定义消息类型 var events = { type, // 消息类型 args: args || {}, // 消息携带数据 }, i = 0, // 消息动作循环变量 len = _messages[type].</description>
    </item>
    
    <item>
      <title>VSCODE 快捷键</title>
      <link>/posts/28/</link>
      <pubDate>Sun, 03 Sep 2023 09:45:34 +0800</pubDate>
      
      <guid>/posts/28/</guid>
      <description>VSCODE 快捷键 </description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>/posts/27/</link>
      <pubDate>Sat, 02 Sep 2023 18:56:18 +0800</pubDate>
      
      <guid>/posts/27/</guid>
      <description>父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些步骤。
创建基本提示框 首先要做的就是创建一个基本提示框基类，然后其他提示框类只需要在继承基础上，拓展自己所需即可。
// 模板类 基础提示框 data 渲染数据 var Alert = function (data) { // 没有数据则返回，防止后面程序执行 if (!data) { return; } // 设置内容 this.content = data.content; // 创建提示框面板 this.panel = document.createElement(&amp;#34;div&amp;#34;); // 创建提示内容组件 this.contentNode = document.createElement(&amp;#34;p&amp;#34;); // 创建确定按钮组件 this.confirmBtn = document.createElement(&amp;#34;span&amp;#34;); // 创建关闭按钮组件 this.closeBtn = document.createElement(&amp;#34;b&amp;#34;); // 为提示框面板添加类 this.panel.className = &amp;#34;alert&amp;#34;; // 为关闭按钮添加类 this.closeBtn.className = &amp;#34;a-close&amp;#34;; // 为确定按钮添加类 this.confirmBtn.className = &amp;#34;a-confirm&amp;#34;; // 为确定按钮添加文件 this.confirmBtn.innerHTML = data.confirm || &amp;#34;确认&amp;#34;; // 为提示内容添加文本 this.</description>
    </item>
    
    <item>
      <title>reset.css 知多少</title>
      <link>/posts/26/</link>
      <pubDate>Sat, 02 Sep 2023 12:23:14 +0800</pubDate>
      
      <guid>/posts/26/</guid>
      <description>大部分的时候，作为前端，我们在写 CSS 样式之前，都知道需要添加一份 reset.css ，但是有深究过 reset.css 每一句的人恐怕不多，其实其中也是有很多学问的，知己知彼，真正厘清它，对提高 CSS 大有裨益。
reset.css 先来看看早先 YUI 的一个版本的 reset.css，这是一份历史比较悠久的 RESET 方案:
body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td { margin: 0; padding: 0; } table { border-collapse: collapse; border-spacing: 0; } fieldset, img { border: 0; } address, caption, cite, code, dfn, em, strong, th, var { font-style: normal; font-weight: normal; } ol, ul { list-style: none; } caption, th { text-align: left; } h1, h2, h3, h4, h5, h6 { font-size: 100%; font-weight: normal; } q:before, q:after { content: &amp;#34;&amp;#34;; } abbr, acronym { border: 0; } 首先，我们要知道 CSS RESET 的目的是什么？是为了消除不同的浏览器在默认样式上不同表现，但是到今天，现代浏览器在这方面的差异已经小了很多。</description>
    </item>
    
    <item>
      <title>现代 CSS 解决方案:CSS 数学函数</title>
      <link>/posts/25/</link>
      <pubDate>Sat, 02 Sep 2023 11:41:00 +0800</pubDate>
      
      <guid>/posts/25/</guid>
      <description>在 CSS 中，其实存在各种各样的函数。具体分为：
Transform functions Math functions Filter functions Color functions Image functions Counter functions Font functions Shape functions Reference functions CSS grid functions 本文，将具体介绍其中的 CSS 数学函数（Math functions）中，已经被浏览器大规模支持的 4 个：
calc() min() max() clamp() 为什么说是被浏览器大规模支持的？因为除了这 4 个目前已经得到大规模支持的数学函数外，其实规范 CSS Values and Units Module Level 4 已经定义了诸如三角函数相关 sin()、cos()、tan() 等，指数函数相关 pow()、sqrt() 等等数学函数，只是目前都处于实验室阶段，还没有浏览器支持它们，需要给时间一点时间。
Calc() calc() 此 CSS 函数允许在声明 CSS 属性值时执行一些计算。
语法类似于
{ width: calc(100% - 80px); } 一些需要注意的点：
+ 和 - 运算符的两边必须要有空白字符。比如，calc(50% -8px) 会被解析成为一个无效的表达式，必须写成calc(8px + -50%) * 和 / 这两个运算符前后不需要空白字符，但如果考虑到统一性，仍然推荐加上空白符 用 0 作除数会使 HTML 解析器抛出异常 涉及自动布局和固定布局的表格中的表列、表列组、表行、表行组和表单元格的宽度和高度百分比的数学表达式，auto 可视为已指定。 calc() 函数支持嵌套，但支持的方式是：把被嵌套的 calc() 函数全当成普通的括号。（所以，函数内直接用括号就好了。） calc() 支持与 CSS 变量混合使用 看一个最常见的例子，页面结构如下：</description>
    </item>
    
    <item>
      <title>21条CSS高级技巧</title>
      <link>/posts/24/</link>
      <pubDate>Sat, 02 Sep 2023 10:59:54 +0800</pubDate>
      
      <guid>/posts/24/</guid>
      <description>使用 CSS 复位 CSS 复位可以在不同的浏览器上保持一致的样式风格。您可以使用 CSS reset 库Normalize等，也可以使用一个更简化的复位方法：
* { box-sizing: border-box; margin: 0; padding: 0; } 现在元素的 margin 和 padding 已为 0，box-sizing可以管理您的 CSS 盒模型布局。 演示 注意：如果你遵循接下来继承 box-sizing讲解的这个技巧, 你不需要在以上代码中添加 box-sizing 属性。
继承 box-sizing 从 html 元素继承 box-sizing ：
html { box-sizing: border-box; } *, *:before, *:after { box-sizing: inherit; } 如此在插件或其它组件里改变 box-sizing 变得简单。
使用 :not() 选择器来决定表单是否显示边框 先为元素添加边框
/* 添加边框 */ .nav li { border-right: 1px solid #666; } 为最后一个元素去除边框
/* 去掉边框 */ .</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>/posts/23/</link>
      <pubDate>Sat, 02 Sep 2023 09:39:55 +0800</pubDate>
      
      <guid>/posts/23/</guid>
      <description>运用共享技术有效的支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。
享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部数据、内部方法指的是相似或者共有的数据和方法，所以将一部分提取出来减少开销。
享元对象 var Flyweight = function () { // 已创建的元素 var created = []; // 创建一个新闻包装容器 function create() { var dom = document.createElement(&amp;#34;div&amp;#34;); // 将容器插入新闻列表容器中 document.getElementById(&amp;#34;container&amp;#34;).appendChild(dom); // 缓存新创建的元素 created.push(dom); // 返回创建的新元素 return dom; } return { // 获取创建新闻元素方法 getDiv: function () { // 如果已创建的元素小于当前页元素的总个数，则创建 if (created.length &amp;lt; 5) { return create(); } else { // 获取第一个元素，并插入最后面 var div = created.shift(); created.push(div); return div; } }, }; }; 实现需求 var paper = 0, num = 5, len = article.</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>/posts/22/</link>
      <pubDate>Thu, 31 Aug 2023 21:34:58 +0800</pubDate>
      
      <guid>/posts/22/</guid>
      <description>每个成员要有祖先 var News = function () { // 子组件容器 this.children = []; // 当前组件元素 this.element = null; }; News.prototype = { // 定义而不是实现 init: function () { throw new Error(&amp;#34;请重写你的方法&amp;#34;); }, // 定义而不是实现 add: function () { throw new Error(&amp;#34;请重写你的方法&amp;#34;); }, // 定义而不是实现 getElement: function () { throw new Error(&amp;#34;请重写你的方法&amp;#34;); }, }; 组合要有容器类 // 容器类构造函数 var Container = function (id, parent) { // 构造函数继承父类 News.call(this); // 模块 id this.id = id; // 模块的父容器 this.</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>/posts/21/</link>
      <pubDate>Wed, 30 Aug 2023 22:06:48 +0800</pubDate>
      
      <guid>/posts/21/</guid>
      <description>多元化对象 // 多维变量类 // 运动单元 function Speed(x, y) { this.x = x; this.y = y; } Speed.prototype.run = function () { console.log(&amp;#34;运动起来&amp;#34;); }; // 着色单元 function Color(cl) { this.color = cl; } Color.prototype.draw = function () { console.log(&amp;#34;绘制色彩&amp;#34;); }; // 变形单元 function Shape(sp) { this.shape = sp; } Shape.prototype.change = function () { console.log(&amp;#34;改变形状&amp;#34;); }; // 说话单元 function Speek(wd) { this.word = wd; } Speek.prototype.say = function () { console.log(&amp;#34;书写字体&amp;#34;); }; 我们想创建一个球类，并且它可以运动，可以着色。</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>/posts/20/</link>
      <pubDate>Wed, 30 Aug 2023 21:55:19 +0800</pubDate>
      
      <guid>/posts/20/</guid>
      <description> 在不改变原对象的基础上，通过对其进行包装拓展使原有对象可以满足用户的更复杂需求。
// 装饰者 var decorator = function (input, fn) { var input = document.getElementById(input); if (typeof input.onclick === &amp;#34;function&amp;#34;) { var oldClickFn = input.onclick; input.onclick = function () { oldClickFn(); fn(); }; } else { input.onclick = fn; } }; // 使用 decorator(&amp;#34;tel_input&amp;#34;, function () { document.getElementById(&amp;#34;tel_demo_text&amp;#34;).style.display = &amp;#34;none&amp;#34;; }); decorator(&amp;#34;name_input&amp;#34;, function () { document.getElementById(&amp;#34;name_demo_text&amp;#34;).style.display = &amp;#34;none&amp;#34;; }); decorator(&amp;#34;address_input&amp;#34;, function () { document.getElementById(&amp;#34;address_demo_text&amp;#34;).style.display = &amp;#34;none&amp;#34;; }); </description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>/posts/19/</link>
      <pubDate>Wed, 30 Aug 2023 21:18:21 +0800</pubDate>
      
      <guid>/posts/19/</guid>
      <description>将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。
以前所写的功能代码 A(function () { A(&amp;#34;button&amp;#34;).on(&amp;#34;click&amp;#34;, function (e) { //... }); }); jQuery 适配器 公司 A 框架代码书写格式是不是与 jQuery 代码书写格式很像，所以需要在加载完 jQuery 框架后写一个适配器，将我们已有的功能适配到 jQuery。适配器主要的任务是适配两种代码库中不兼容的代码，所以首当其冲的就是全局对象 A 与 jQuery 了，所以可以像下面这样轻松的实现。
window.A = A = jQuery; 适配异类框架 公司的整个轻量级 A 框架太像 jQuery 了，我们可以将两种框架看成是相似框架，但是如果一个框架与 jQuery 血缘远一点，那么对于这种异类框架适配情况就复杂多了，举个例子:
// 定义框架 var A = A || {}; A.g = function (id) { return document.getElementById(id); }; // 为元素绑定事件 A.on = function (id, type, fn) { var dom = typeof id === &amp;#34;string&amp;#34; ?</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>/posts/18/</link>
      <pubDate>Wed, 30 Aug 2023 20:47:36 +0800</pubDate>
      
      <guid>/posts/18/</guid>
      <description>添加一个点击事件 document.onclick = function (e) { e.preventDefault(); if (e.target !== document.getElementById(&amp;#34;myinput&amp;#34;)) { hidePageAlert(); } }; function hidePageAlert() { // 隐藏提示框 } 兼容模式 套餐，定制，简化复杂请求，统一封装，外观模式封装
// 外观模式实现 function addEvent(dom, type, fn) { if (dom.addEventListener) { dom.addEventListener(type, fn, false); } else if (dom.attachEvent) { dom.attachEvent(&amp;#34;on&amp;#34; + type, fn); } else { dom[&amp;#34;on&amp;#34; + type] = fn; } } // 使用 var myInput = document.getElementById(&amp;#34;myinput&amp;#34;); addEvent(myInput, &amp;#34;click&amp;#34;, function () { console.log(&amp;#34;绑定第一个事件&amp;#34;); }); addEvent(myInput, &amp;#34;click&amp;#34;, function () { console.</description>
    </item>
    
    <item>
      <title>CSS will-change</title>
      <link>/posts/17/</link>
      <pubDate>Wed, 30 Aug 2023 13:07:35 +0800</pubDate>
      
      <guid>/posts/17/</guid>
      <description>一、什么是 will-change？ will-change是一个 CSS 属性，它可以告诉浏览器某个元素将要发生的变化。通过明确指定这些变化，浏览器可以事先分配和优化相应的资源，从而提升渲染的性能。
二、will-change 的使用方法 要使用will-change，只需将它应用于你要进行性能优化的元素上。
.element { will-change: transform; } 在上述示例中，我们告诉浏览器，该元素即将发生变换（transform），以便浏览器在渲染时提前分配所需的资源。
值得注意的是，因为will-change是为了性能优化而设计的，滥用它可能会带来负面影响。只在需要优化的元素上使用will-change，避免对所有元素都进行指定。
三、will-change 的原理 要理解will-change的原理，我们需要了解浏览器渲染流程的基本概念。
1. 渲染流程简介 浏览器在渲染网页时，会经历一系列的步骤，如样式计算、布局、绘制和合成。为了提高性能，浏览器会尽量避免进行不必要的计算和操作。
2. will-change 的作用 will-change的作用就是告诉浏览器某个元素将要发生的变化，从而使浏览器在渲染过程中提前分配和优化相应的资源。
例如，当我们设置了will-change: transform时，浏览器会为该元素创建一个独立的图层，将这个图层标记为“即将变换”。这样，在进行布局和绘制时，浏览器就可以更高效地处理这个元素，而无需重新计算整个渲染树。
加入 will-change 后，通过观察复合层，如图下
加入 will-change 后，元素会被提升到单独的复合层，动画（重绘、重排）的操作只会在单独复合层上进行，减少了原来的页面层重绘和重排的行为 注：每一个元素单独加入 will-change 都会单独创建一个复合层，如果给大量的元素加上 will-change 就会创建大量的复合层，反而会影响性能
3. will-change的优化效果 使用will-change可以带来以下优化效果：
减少渲染阻塞：浏览器可以提前分配和优化资源，减少渲染阻塞时间，提高页面的响应速度。 减少重绘和重排：浏览器可以更好地管理渲染过程，避免不必要的重绘和重排，从而提高渲染性能。 硬件加速：某些浏览器对will-change属性会进行硬件加速，进一步提升性能。 4. will-change使用的时机 在很多关于 will-change 的描述，都能够看到类似下面的一段话
在实际更改的元素上将 will-change 设置为您将实际更改的属性。并在他们停止时将其删除。- Tab Atkins Jr.（规范编辑者）
至于为什么？大部分的描述都是因为 will-change 会消耗浏览器 GPU 资源
当元素有 will-change 时，将元素提升到它们自己的“GPU 层”的浏览器。但有太多元素声明时，浏览器将忽略声明，以避免耗尽 GPU 内存
所以对于 will-change 的使用应该控制时机
在适当的时机移除 will-change 就是减少浏览器的复合层，避免过度使用 will-change 带来性能问题</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>/posts/16/</link>
      <pubDate>Tue, 29 Aug 2023 21:32:16 +0800</pubDate>
      
      <guid>/posts/16/</guid>
      <description>单例模式：是只允许实例化一次的对象类。
命名空间的管理员 单例模式常用来定义命名空间
var Ming = { g: function (id) { return document.getElementById(id); }, css: function (id, key, value) { this.g(id).style[key] = value; }, }; 模块分明 单例模式除了定义命名空间外，还有一个作用，就是通过单例模式来管理代码库的各个模块，
baidu.dom.addClass #添加元素类 baidu.dom.append #插入元素 baidu.event.stopPropagation #阻止冒泡 baidu.event.preventDefault #阻止默认行为 baidu.event.trim #去除字符串收尾空白符 baidu.string.encodeHTML #将字符串进行html编码 创建一个小型代码库 我们也可以用单例模式来规范我们自己代码库的各个模块，比如我们有一个 A 库，它包含公用模块、工具模块、ajax 模块和其他模块，我们就可以自己定制一个如下的小型代码库。
var A = { Util: { util_method1: function () {}, util_method2: function () {}, //... }, Tool: { tool_method1: function () {}, tool_method2: function () {}, //.</description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>/posts/15/</link>
      <pubDate>Tue, 29 Aug 2023 17:16:23 +0800</pubDate>
      
      <guid>/posts/15/</guid>
      <description>创建一个焦点图 假设页面中有很多焦点图，那么我们要实现这些焦点图最好的方式就是通过创建对象来一一实现。我们就需要有一个焦点类，比如我们把这个类定义为 LoopImages。
// 图片轮播类 var LoopImages = function (imgArr, container) { this.imagesArray = imgArr; this.container = container; this.createImage = function () {}; this.changeImage = function () {}; }; 如果一个页面中有多个焦点图，其切换动画一般是多样化的，有的可能是上下切换，有的可能是左右切换，有的可能是渐隐渐现，有的可能是放缩切换，等等。因此创建的轮播图片结构应该是多样化的，同样切换的效果也应该是多样化的，因此我们应该抽象出一个基类，让不同特效去继承这个基类，然后对于差异化的需求通过重写这些继承下来的属性或方法来解决。
比如，有一个包含左右切换箭头，如下：
// 上下滑动切换类 var SlideLoopImg = function (imgArr, container) { LoopImages.call(this, imgArr, container); this.changeImage = function () { console.log(&amp;#34;SlideLoopImg changeImage function&amp;#34;); }; }; // 渐隐切换类 var FadeLoopImg = function (imgArr, container, arrow) { LoopImages.call(this, imgArr, container); this.arrow = arrow; this.changeImage = function () { console.</description>
    </item>
    
    <item>
      <title>前端异常监控解决方案研究</title>
      <link>/posts/14/</link>
      <pubDate>Tue, 29 Aug 2023 17:05:52 +0800</pubDate>
      
      <guid>/posts/14/</guid>
      <description>前端监控包括行为监控、异常监控、性能监控等，本文主要讨论异常监控。对于前端而言，和后端处于同一个监控系统中，前端有自己的监控方案，后端也有自己等监控方案，但两者并不分离，因为一个用户在操作应用过程中如果出现异常，有可能是前端引起，也有可能是后端引起，需要有一个机制，将前后端串联起来，使监控本身统一于监控系统。因此，即使只讨论前端异常监控，其实也不能严格区分前后端界限，而要根据实际系统的设计，在最终的报表中体现出监控对开发和业务的帮助。
一般而言，一个监控系统，大致可以分为四个阶段：日志采集、日志存储、统计与分析、报告和警告。
采集阶段：收集异常日志，先在本地做一定的处理，采取一定的方案上报到服务器。
存储阶段：后端接收前端上报的异常日志，经过一定处理，按照一定的存储方案存储。
分析阶段：分为机器自动分析和人工分析。机器自动分析，通过预设的条件和算法，对存储的日志信息进行统计和筛选，发现问题，触发报警。人工分析，通过提供一个可视化的数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常问题根源。
报警阶段：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。
1 前端异常 前端异常是指在用户使用 Web 应用时无法快速得到符合预期结果的情况，不同的异常带来的后果程度不同，轻则引起用户使用不悦，重则导致产品无法使用，使用户丧失对产品的认可。
1.1 前端异常分类 根据异常代码的后果的程度，对前端异常的表现分为如下几类
a. 出错
界面呈现的内容与用户预期的内容不符，例如点击进入非目标界面，数据不准确，出现的错误提示不可理解，界面错位，提交后跳转到错误界面等情况。这类异常出现时，虽然产品本身功能还能正常使用，但用户无法达成自己目标。
b. 呆滞
界面出现操作后没有反应的现象，例如点击按钮无法提交，提示成功后无法继续操作。这类异常出现时，产品已经存在界面级局部不可用现象。
c. 损坏
界面出现无法实现操作目的的现象，例如点击无法进入目标界面，点击无法查看详情内容等。这类异常出现时，应用部分功能无法被正常使用。
d. 假死
界面出现卡顿，无法对任何功能进行使用的现象。例如用户无法登陆导致无法使用应用内功能，由于某个遮罩层阻挡且不可关闭导致无法进行任何后续操作。这类异常出现时，用户很可能杀死应用。
e. 崩溃
应用出现经常性自动退出或无法操作的现象。例如间歇性 crash，网页无法正常加载或加载后无法进行任何操作。这类异常持续出现，将直接导致用户流失，影响产品生命力。
1.2 异常错误原因分类 前端产生异常的原因主要分 5 类：
原因案例频率逻辑错误1) 业务逻辑判断条件错误
2) 事件绑定顺序错误
3) 调用栈时序错误
4) 错误的操作js对象经常数据类型错误1) 将null视作对象读取property
2) 将undefined视作数组进行遍历
3) 将字符串形式的数字直接用于加运算
4) 函数参数未传经常语法句法错误较少网络错误1) 慢
2) 服务端未返回数据但仍200，前端按正常进行数据遍历
3) 提交数据时网络中断
4) 服务端500错误时前端未做任何错误处理偶尔系统错误1) 内存不够用
2) 磁盘塞满
3) 壳不支持API
4) 不兼容较少2 异常采集 2.1 采集内容 当异常出现的时候，我们需要知道异常的具体信息，根据异常的具体信息来决定采用什么样的解决方案。在采集异常信息时，可以遵循 4W 原则：</description>
    </item>
    
    <item>
      <title>JS错误监控篇</title>
      <link>/posts/13/</link>
      <pubDate>Tue, 29 Aug 2023 16:59:15 +0800</pubDate>
      
      <guid>/posts/13/</guid>
      <description>监控流程：监控并收集错误 -&amp;gt; 存储并上报错误 -&amp;gt; 分析并聚合错误 -&amp;gt; 发送错误报警-&amp;gt; 定位并解决 JS 错误
一、监控并收集 Javascript 错误 众所周知，我们是有办法去监听前端 Js 错误的，他们分别 window.onerror、window.onunhandledrejection、console.error 方法。
通过这些方法能够为我们记录下线上的运行时错误，以及详细的堆栈信息。我将 window.onerror(捕获异常)，console.error(自定义异常) 方法收集到的错误信息进行分析统计后的效果如下：
（1）重写 window.onerror 方法 // 重写 onerror 进行jsError的监听 window.onerror = function (errorMsg, url, lineNumber, columnNumber, errorObj) { var errorStack = errorObj ? errorObj.stack : null; siftAndMakeUpMessage( &amp;#34;on_error&amp;#34;, errorMsg, url, lineNumber, columnNumber, errorStack ); }; window.onerror 方法以及它的参数我就不一一介绍了，我相信大家也已经耳熟能详了；我们记录下错误发生时的行、列号，以及错误堆栈。
（2）重写 window.onunhandledrejection 方法 window.onunhandledrejection = function (e) { var errorMsg = &amp;#34;&amp;#34;; var errorStack = &amp;#34;&amp;#34;; if (typeof e.</description>
    </item>
    
    <item>
      <title>前端异常处理最佳实践</title>
      <link>/posts/12/</link>
      <pubDate>Tue, 29 Aug 2023 16:27:16 +0800</pubDate>
      
      <guid>/posts/12/</guid>
      <description>前端可以说是最贴近用户的一层，当产品不断的迭代完善，产品的用户体验会更加趋向于完美，然而前端异常却是很另人头疼的一个问题，我们应该怎么去对待这些异常呢？
一、为什么要处理异常？
异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。
增强用户体验； 远程定位问题； 未雨绸缪，及早发现问题； 无法复线问题，尤其是移动端，机型，系统都是问题； 完善的前端方案，前端监控系统； 对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。
二、需要处理哪些异常？
对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：
JS 语法错误、代码异常 AJAX 请求异常 静态资源加载异常 Promise 异常 Iframe 异常 跨域 Script error 崩溃和卡顿 下面我会针对每种具体情况来说明如何处理这些异常。
三、Try-Catch 的误区
try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。
1、同步运行时错误：
输出：
2、不能捕获到语法错误，我们修改一下代码，删掉一个单引号：
输出：
不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。
3、异步错误
可以看看日志：
并没有捕获到异常，这是需要我们特别注意的地方。
四、window.onerror 不是万能的
当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。
1、首先试试同步运行时错误
可以看到，我们捕获到了异常：
2、再试试语法错误呢？
控制台打印出了这样的异常：
竟然没有捕获到语法错误？
3、怀着忐忑的心，我们最后来试试异步运行时错误：
控制台输出了：
4、接着，我们试试网络请求异常的情况：
我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。
补充一点： window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx
控制台就不会再有这样的错误了：</description>
    </item>
    
    <item>
      <title>高效加载第三方JavaScript</title>
      <link>/posts/11/</link>
      <pubDate>Tue, 29 Aug 2023 16:16:21 +0800</pubDate>
      
      <guid>/posts/11/</guid>
      <description>如果第三方脚本降低您的页面加载速度，您有两个选项可以提高性能：
如果它没有为您的网站增加明确的价值，请将其删除。 优化加载过程。 本文解释如何使用以下技术优化第三方脚本的加载过程：
针对 &amp;lt;script&amp;gt; 标记使用 async 或 defer 属性 建立与所需来源的早期连接 延迟加载 优化您使用第三方脚本的方式 使用 async 或 defer 由于同步脚本会延迟 DOM 构建和呈现，因此您应该始终异步加载第三方脚本，除非脚本必须在页面呈现之前运行。
async 和 defer 属性告诉浏览器其可以在后台加载脚本时继续解析 HTML，然后在加载后执行脚本。这样，脚本下载不会阻止 DOM 构建和页面呈现。这样，用户就可以在所有脚本加载完成之前看到页面。
&amp;lt;script async src=&amp;#34;script.js&amp;#34;&amp;gt; &amp;lt;script defer src=&amp;#34;script.js&amp;#34;&amp;gt; async 和 defer 之间的区别在于它们何时开始执行脚本。
async 具有 async 属性的脚本在完成下载后和窗口加载事件之前第一时间执行。这意味着 async 脚本可能（并且很可能）不会按照它们在 HTML 中出现的顺序执行。这也意味着如果它们在解析器仍在工作时完成下载，他们可以中断 DOM 构建。
defer 具有 defer 属性的脚本在 HTML 解析完全完成之后执行，但在 DOMContentLoaded 事件之前执行。defer 保证脚本将按照它们在 HTML 中出现的顺序执行并且不会阻塞解析器。
如果在加载过程中更早地运行脚本很重要，请使用 async。 对不太重要的资源使用 defer。例如，低于首屏的视频播放器。 使用这些属性可以显著加快页面加载速度。例如，Telegraph 最近推迟了所有脚本，包括广告和分析，并将广告加载时间平均缩短了四秒。
分析脚本通常会提前加载，因此您不会错过任何有价值的分析数据。幸运的是，有一些模式可以在保留早期页面加载数据的同时延迟初始化分析。
建立与所需来源的早期联系 通过与重要的第三方来源建立早期连接，您可以节省 100–500 毫秒。</description>
    </item>
    
    <item>
      <title>ES6到ES12常用新特性</title>
      <link>/posts/10/</link>
      <pubDate>Tue, 29 Aug 2023 10:14:46 +0800</pubDate>
      
      <guid>/posts/10/</guid>
      <description>ES 是什么？ ES 是 ECMAScript 的缩写，也就是 JavaScript 的标准化规范。ECMAScript 是一种由 Ecma 国际组织制定的脚本语言标准，它定义了 JavaScript 的语法、类型、操作符、对象和函数等基本组件。ES6（也称为 ES2015）是 ECMAScript 的第六个版本，引入了许多新的语言特性和改进，如箭头函数、模板字面量、解构赋值等。随后的版本（如 ES7、ES8 等）也引入了许多新的功能和语法糖，以进一步改进和扩展 JavaScript。
各版本特性总结 版本 特性 描述 ES6 let 和 const 关键字 引入了块级作用域声明变量的关键字 let 和常量声明变量的关键字 const ES6 函数参数默认值 允许在函数定义时为参数设置默认值 ES6 箭头函数 使用箭头 (=&amp;gt;) 定义函数，简化了函数的写法，并且自动绑定了当前作用域的 this ES6 模板字符串 使用反引号 (`) 来定义字符串，可以在字符串中插入变量或表达式，并支持多行字符串 ES6 扩展操作符 使用扩展操作符 (&amp;hellip;) 可以将数组或对象展开为单独的元素 ES6 解构赋值 可以从数组或对象中提取值并赋给变量 ES6 对象字面量简化 简化了对象的定义和属性的赋值方式 ES6 类 引入了类和继承的概念，使得 JavaScript 更像面向对象编程语言 ES6 模块化 支持使用 import 和 export 关键字进行模块化开发，可以方便地导入和导出模块 ES6 Promise 提供了一种更优雅的方式来处理异步操作，解决了回调地狱的问题 ES6 Symbol 引入了一种新的原始数据类型 Symbol，可以用来创建唯一的标识符 ES6 Map/WeakMap 和 Set/WeakSet 数据结构 提供了更灵活和高效的数据结构，Map 是一种键值对的集合，Set 是一种无重复值的集合，WeakMap 和 WeakSet 是弱引用版本，可以更好地处理内存和垃圾回收的问题 ES6 迭代器（Iterator）和 for&amp;hellip;of 迭代器提供了一种遍历集合的方式，for&amp;hellip;of 循环可以直接遍历可迭代对象 ES6 生成器（Generator） 可以生成多个值的函数，使用 function* 和 yield 关键字定义，可以暂停和恢复函数的执行 ES6 Proxy 提供了拦截和自定义操作的机制，可以代理对目标对象的访问和修改操作 ES6 Reflect 提供了一组静态方法来操作对象，比如获取对象的属性描述符、动态调用对象的方法等 ES6 数组对象扩展 引入了一些新的方法和属性，比如 Array.</description>
    </item>
    
    <item>
      <title>50个JS高级知识点</title>
      <link>/posts/09/</link>
      <pubDate>Tue, 29 Aug 2023 09:30:43 +0800</pubDate>
      
      <guid>/posts/09/</guid>
      <description>知识点 1、undeclared 与 undefined 的区别？ undefined：声明了变量，但是没有赋值 undeclared：没有声明变量就直接使用 var a; //undefined b; // b is not defined 2、let &amp;amp; const 与 var 的区别？ var 存在变量提升，可重复声明同一变量，声明的变量均可改 let 没有变量提升，不可重复声明同一变量，声明的变量均可改 const 没有变量提升，不可重复声明同一变量，声明的基本数据类型不可改，引用类型可改属性，不可只声明变量而不赋值 3、暂时性死区问题 var a = 100; if (1) { a = 10; //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a， // 而这时，还未到声明时候，所以控制台Error:a is not defined let a = 1; } 4、获取 DOM 元素有哪些方法 方法 描述 返回类型 document.getElementById(id) 通过 id 获取 dom 符合条件的 dom 对象 document.getElementsByTagName(tagName) 通过标签名获取 dom 符合条件的所有 dom 对象组成的类数组 document.</description>
    </item>
    
    <item>
      <title>真正理解Promise</title>
      <link>/posts/08/</link>
      <pubDate>Sun, 27 Aug 2023 22:32:16 +0800</pubDate>
      
      <guid>/posts/08/</guid>
      <description>Promise 的简单介绍 Promise 是用来进行异步编程的。在 Promise 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&amp;#34;load&amp;#34;, function (data) { console.log(data); }); xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr.send(); 这种方式有一个致命的缺点，那就是回调地狱，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&amp;#34;load&amp;#34;, function (data) { console.log(data); const xhr1 = new XMLHttpRequest(); xhr1.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr1.send(); xhr1.addEventListener(&amp;#34;load&amp;#34;, function (data1) { console.log(data1); //... 发送第三个请求 }); }); xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr.send(); 这种代码不仅看起来很痛苦，写起来也非常痛苦。而 Promise 就是用来解决这个问题的，可以把 Promise 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态改变只有两种：从 pending 变为 fulfilled 或从 pending 变为 rejected ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 resolve 函数使得状态变为 fulfilled，reject 函数使得状态变为 rejected。</description>
    </item>
    
    <item>
      <title>10种JavaScript快乐写法</title>
      <link>/posts/07/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:42 +0800</pubDate>
      
      <guid>/posts/07/</guid>
      <description>数组去重 方式一 const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = Array.from(new Set(arr)); // const uniqueArr = [...new Set(arr)]; 方式二 const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = []; arr.forEach((item) =&amp;gt; { // 或者!uniqueArr.includes(item) if (uniqueArr.indexOf(item) === -1) { uniqueArr.push(item); } }); const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = arr.filter((item, index) =&amp;gt; { return arr.</description>
    </item>
    
    <item>
      <title>建造者模式</title>
      <link>/posts/06/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:40 +0800</pubDate>
      
      <guid>/posts/06/</guid>
      <description>建造者模式：将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不用的表示。
创建对象的另一种形式 // 创建一位人类 var Human = function (param) { // 技能 this.skill = (param &amp;amp;&amp;amp; param.skill) || &amp;#34;保密&amp;#34;; // 兴趣爱好 this.hobby = (param &amp;amp;&amp;amp; param.hobby) || &amp;#34;保密&amp;#34;; }; // 类人原型方法 Human.prototype = { getSkill: function () { return this.skill; }, getHobby: function () { return this.hobby; }, }; // 实例化姓名类 var Named = function (name) { var that = this; // 构造器 // 构造函数解析姓名的姓与名 (function (name, that) { that.</description>
    </item>
    
    <item>
      <title>抽象工厂模式</title>
      <link>/posts/05/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:37 +0800</pubDate>
      
      <guid>/posts/05/</guid>
      <description>抽象类 是一种声明了但不能使用的类，当你使用的时候就会报错。
// 汽车抽象类，当使用其实例对象的方法时会抛出错误 var Car = function () {}; Car.prototype = { getPrice: function () { return new Error(&amp;#34;抽象方法不能调用&amp;#34;); }, getSpeed: function () { return new Error(&amp;#34;抽象方法不能调用&amp;#34;); }, }; 如上，创建这个 Car 类其实什么都不用做，创建时没有任何属性，然后其原型上方法也不能使用，否则会报错。但在继承上很有用，因为定义了一种类，并定义了该类所必备的方法，如果在子类中没有重写这些方法，那调用的时候就会报错。
抽象工厂模式 直接赋值是无法实现正确的继承关系的。如果直接将子类的原型设置为父类的实例，那么子类的原型对象将直接引用父类的实例对象，这样在修改子类的原型时会直接影响到父类的实例。而使用 F 函数作为中转，可以通过 F 函数的实例来实现子类对父类的继承，同时保持子类和父类的独立性，避免相互影响。这样子类可以自由地修改自己的原型对象，而不会影响到父类或其他子类的实例。因此，使用 F 函数作为中转是为了正确实现继承关系和保持对象的独立性。
// 抽象工厂方法 var VehicleFactory = function (subType, superType) { // 判断抽象工厂中是否有该抽象类 if (typeof VehicleFactory[superType] === &amp;#34;function&amp;#34;) { // 缓存类 function F() {} // 继承父类属性和方法 F.prototype = new VehicleFactory[superType](); // 将子类 constructor 指向子类 superType.</description>
    </item>
    
    <item>
      <title>ES2016到ES2023新特性</title>
      <link>/posts/04/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:35 +0800</pubDate>
      
      <guid>/posts/04/</guid>
      <description>ES2016 Array.prototype.includes() 这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false
// 我有一个水果篮子 const fruitBasket = [&amp;#34;apple&amp;#34;, &amp;#34;banana&amp;#34;, &amp;#34;orange&amp;#34;, &amp;#34;grape&amp;#34;]; // 我要检查篮子里是否有橙子 const hasOrange = fruitBasket.includes(&amp;#34;orange&amp;#34;); console.log(hasOrange); // 输出: true // 我还想知道篮子里是否有葡萄 const hasGrape = fruitBasket.includes(&amp;#34;grape&amp;#34;); console.log(hasGrape); // 输出: true // 现在我要检查篮子里是否有西瓜 const hasWatermelon = fruitBasket.includes(&amp;#34;watermelon&amp;#34;); console.log(hasWatermelon); // 输出: false 求幂运算符 求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂
// 我要计算 2 的 3 次幂 const result = 2 ** 3; console.log(result); // 输出: 8 ES2017 Object.values / Object.entries const person = { name: &amp;#34;Alice&amp;#34;, age: 25, city: &amp;#34;New York&amp;#34;, }; const values = Object.</description>
    </item>
    
    <item>
      <title>工厂方法模式</title>
      <link>/posts/03/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:33 +0800</pubDate>
      
      <guid>/posts/03/</guid>
      <description>安全工厂方法 // 安全模式创建的工厂类 var Factory = function (type, content) { if (this instanceof Factory) { var s = new this[type](content); return s; } else { return new Factory(type, content); } }; // 工厂原型中设置创建所有类型数据对象的基类 Factory.prototype = { Java: function (content) { //... }, JavaScript: function (content) { //... }, UI: function (content) { this.content = content; (function (content) { var div = document.createElement(&amp;#34;div&amp;#34;); div.innerHTML = content; div.style.border = &amp;#34;1px solid red&amp;#34;; document.</description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>/posts/02/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:30 +0800</pubDate>
      
      <guid>/posts/02/</guid>
      <description>又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建用一类对象。
工作中的一次需求 var LoginAlert = function (text) { this.content = text; }; LoginAlert.prototype.show = function () { // 显示警示框 }; var userNameAlert = new LoginAlert(&amp;#34;用户名不能多于 16 个字母或数字&amp;#34;); userNameAlert.show(); 上面的类，如果对于多种场景，就不那么适用了；可能要需要定义多个类。
如果类太多，那么提供一个 // 篮球基类 var Basketball = function () { this.intro = &amp;#34;篮球盛行于美国&amp;#34;; }; Basketball.prototype = { getMember: function () { console.log(&amp;#34;每个队伍需要5名队员&amp;#34;); }, getBallSize: function () { console.log(&amp;#34;篮球很大&amp;#34;); }, }; // 足球基类 var Football = function () { this.intro = &amp;#34;足球在世界范围内很流行&amp;#34;; }; Football.</description>
    </item>
    
    <item>
      <title>面向对象编程</title>
      <link>/posts/01/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:28 +0800</pubDate>
      
      <guid>/posts/01/</guid>
      <description>封装 创建一个类 var Book = function (id, bookname, price) { this.id = id; this.bookname = bookname; this.price = price; }; 也可以通过在类的原型上添加属性和方法 Book.prototype.display = function () { // 展示这本书 }; // 或者 Book.prototype = { display: function () { // 展示这本书 }, }; 实例化使用类 var book = new Book(10, &amp;#34;JavaScript 设计模式&amp;#34;, 50); console.log(book.bookname); 属性与方法封装 var Book = function (id, name, price) { // 私有属性 var num = 1; // 私有方法 function checkId() {} // 特权方法 this.</description>
    </item>
    
  </channel>
</rss>
