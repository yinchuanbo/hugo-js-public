<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>灏天阁</title>
    <link>/</link>
    <description>Recent content on 灏天阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2008–2019, Steve Francia and the lee.so; all rights reserved.</copyright>
    <lastBuildDate>Mon, 18 Sep 2023 14:09:13 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>scrollIntoview</title>
      <link>/posts/54/</link>
      <pubDate>Mon, 18 Sep 2023 14:09:13 +0800</pubDate>
      
      <guid>/posts/54/</guid>
      <description>大家可能都知道 dom 有一个 scrollIntoview方法，它可以轻易的让目标元素滚动到可视范围之内，而无需手动计算偏移量
dom.scrollIntoview(); 效果如下
这样跳转比较生硬，因此可能还知道有这样一个参数
dom.scrollIntoview({ behavior: &amp;#34;smooth&amp;#34;, }); 这样就能平滑滚动了
仅仅只有这些了吗？其实还可以做很多
一、重新学习 scrollIntoView 语法 打开 MDN 官网
https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView
语法其实很简单，有三种形式
scrollIntoView(); scrollIntoView(alignToTop); scrollIntoView(scrollIntoViewOptions); 首先看第 2 种形式，就一个参数 「alignToTop」 布尔值
默认为 true，表示是否沿着元素的顶端和滚动容器对齐，否则和元素底端对齐。
dom.scrollIntoView(); dom.scrollIntoView(true); 这两种效果是相同的
如果设置为false，那么会居底部对齐
dom.scrollIntoview(false); 效果如下
注意，「alignToTop」 自适应于 「垂直方向」 上的滚动，如果是 「水平方向」 的滚动，设置了没有任何区别。
// 水平滚动下，以下 3 种写法作用相同 dom.scrollIntoview(); dom.scrollIntoview(true); dom.scrollIntoview(false); 效果都是一样的，如下
🤔 为啥是居右侧对齐呢？同时为了满足两个方向上的灵活控制，出现了 「scrollIntoViewOptions」 参数。
这个稍微复杂一点，接着往下看。
二、详解 scrollIntoViewOptions 参数 「scrollIntoViewOptions」 是一个对象，包含 3 个属性，分别是 「behavior」、「block」、「inline」
dom.scrollIntoView({ behavior: &amp;#34;smooth&amp;#34;, block: &amp;#34;end&amp;#34;, inline: &amp;#34;nearest&amp;#34;, }); 首先来看 「behavior」 属性，这是用来定义滚动动画的，有 3 个关键词</description>
    </item>
    
    <item>
      <title>CSS网格布局</title>
      <link>/posts/53/</link>
      <pubDate>Sun, 17 Sep 2023 22:09:38 +0800</pubDate>
      
      <guid>/posts/53/</guid>
      <description>&amp;lt;div id=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;item item-1&amp;#34;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-2&amp;#34;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-3&amp;#34;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-4&amp;#34;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-5&amp;#34;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-6&amp;#34;&amp;gt;6&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-7&amp;#34;&amp;gt;7&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-8&amp;#34;&amp;gt;8&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item item-9&amp;#34;&amp;gt;9&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; #container { display: grid; grid-template-columns: 50px 50px 50px; grid-template-rows: 50px 50px 50px; grid-gap: 10px; } .item { border: 1px solid red; text-align: center; line-height: 50px; } 使用百分比定义列宽和列高：
#container { display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%; /* 需要给 #container 设置一个高度 */ } 如上，重复书写比较麻烦，可以使用 repeat() 函数</description>
    </item>
    
    <item>
      <title> 一些 css 语法解释</title>
      <link>/posts/52/</link>
      <pubDate>Sun, 17 Sep 2023 21:58:31 +0800</pubDate>
      
      <guid>/posts/52/</guid>
      <description>filter: invert(1) 是一种 CSS 滤镜效果，它用于将元素的颜色进行反转，即将亮色变为暗色，暗色变为亮色。具体而言，它将元素的亮度值进行反转，使得黑色变为白色，白色变为黑色，其他颜色也会相应地进行反转。这个滤镜效果常用于创建黑暗主题、反色效果或者增强视觉对比度。
-webkit-autofill .contac__input: -webkit-autofill { transition: background-color 6000s, color 6000s; } 这段代码是用于自动填充表单输入框的样式设置。 -webkit-autofill 是一个 Webkit 浏览器的伪类选择器，用于匹配自动填充的表单字段。
transition: background-color 6000s, color 6000s; 是一个过渡效果的设置，它定义了在 6000 秒内发生的过渡效果。具体来说，它定义了在自动填充表单字段时，背景颜色和文字颜色的过渡效果。
这段代码的作用是为自动填充表单字段提供过渡效果，使得填充的背景颜色和文字颜色能够平滑地改变，提升用户体验。
placeholder-shown .contact__input:not(:placeholder-shown).contact__input:not(:focus) + .contact__label { opacity: 1; top: -16px; } 这段代码是用于在表单输入框中输入内容时，控制相邻标签的样式变化。具体来说：
.contact__input:not(:placeholder-shown).contact__input:not(:focus) 选择器表示选中没有占位符文本且没有获得焦点的输入框。
+ .contact__label 表示选中与上述选择器相邻的类名为 .contact__label 的元素。
opacity: 1; 设置透明度为 1，即完全不透明。
top: -16px 将元素的位置向上移动 16 像素。
这段代码的作用是在用户在输入框中输入内容时，将相邻的标签元素显示出来，并将其位置向上移动 16 像素。通常用于实现输入框中的占位标签在输入内容时的动态效果，提升用户体验。
margin-inline .contact__data { margin-inline: auto; } 这段代码设置了类名为 .contact__data 的元素的水平居中对齐。具体来说：
margin-inline: auto; 是一个 CSS 属性，用于设置元素的水平外边距。 auto 值表示自动计算外边距，使元素在水平方向上居中对齐。</description>
    </item>
    
    <item>
      <title>创建带有曲线的侧边栏菜单</title>
      <link>/posts/51/</link>
      <pubDate>Sun, 17 Sep 2023 21:33:06 +0800</pubDate>
      
      <guid>/posts/51/</guid>
      <description>具体代码如下: HTML
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;link href=&amp;#34;https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css&amp;#34; rel=&amp;#34;stylesheet&amp;#34; /&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;assets/css/styles.css&amp;#34; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;nav class=&amp;#34;nav&amp;#34;&amp;gt; &amp;lt;ul class=&amp;#34;nav__list&amp;#34;&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; class=&amp;#34;nav__link active-link&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;ri-dashboard-3-line&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span class=&amp;#34;nav__name&amp;#34;&amp;gt;Home&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; class=&amp;#34;nav__link&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;ri-account-box-line&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span class=&amp;#34;nav__name&amp;#34;&amp;gt;Accounts&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; class=&amp;#34;nav__link&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;ri-rocket-line&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span class=&amp;#34;nav__name&amp;#34;&amp;gt;Investments&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; class=&amp;#34;nav__link&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;ri-file-list-3-line&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span class=&amp;#34;nav__name&amp;#34;&amp;gt;Files&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; class=&amp;#34;nav__link&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;ri-settings-3-line&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span class=&amp;#34;nav__name&amp;#34;&amp;gt;Settings&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>渲染优化</title>
      <link>/posts/50/</link>
      <pubDate>Sun, 17 Sep 2023 16:42:43 +0800</pubDate>
      
      <guid>/posts/50/</guid>
      <description>如果把浏览器呈现页面的整个过程一分为二，前面讨论的的诸如图像资源优化、加载优化，以及构建中如何压缩资源大小等，都可视为浏览器为呈现页面请求所需资源的部分，本章主要关注浏览器获取资源后，进行渲染部分的相关优化内容。
页面渲染性能 流畅的使用体验 网站页面要快速加载出来，而且运行过程也应更顺畅。
那么要达到在怎样的性能指标，才能满足用户流畅的使用体验呢？
目前大部分设备的屏幕分辨率都在 60fps 左右，也就是每秒刷新 60 次，所以要满足用户的体验期望，就需要浏览器在渲染页面动画或响应用户操作时，每一帧的生成速率尽量接近屏幕的刷新率。
若按照 60fps 来算，则留给每一帧画面的时间不到 17ms，再除去浏览器对资源的一些整理工作，一帧画面的渲染应尽量再 10ms 内完成，如果达不到要求而导致帧率下降，则屏幕上的内容会发生抖动或卡顿。
渲染过程 为了使每一帧页面渲染的开销都能在期望的时间范围内完成，就需要开发者了解渲染过程的每个阶段，以及各个阶段有哪些优化空间是我们力能所及的，
经过分析根据开发者对优化渲染过程的控制力度，可以大体将其划分为五个部分：
JavaScript 处理、计算样式、页面布局、绘制、合成
JavaScript 处理： 前端项目中经常会需要响应用户操作，通过 JavaScript 对数据集进行计算、操作 DOM 元素，并展示动画等视觉效果。当然对于动画的实现，除了 JavaScript，也可以考虑使用如 CSS Animations、Transitions 等技术。
计算样式： 在解析 CSS 文件后，浏览器需要根据各种选择器去匹配所要应用 CSS 规则的元素节点，然后计算出每个元素的最终样式。
页面布局： 指的是浏览器在计算完样式后，会对每个元素尺寸大小和屏幕位置进行计算。由于每个元素都可能会受到其他元素的影响，并且位于 DOM 树形结构中子节点元素，总会受到父级元素修改的影响，所以页面布局的计算会经常发生。
绘制： 在页面布局确定后，接下来便可以绘制元素的可视内容，包括颜色、边框、阴影及文本和图像。
合成： 通常由于页面中的不同部分可能被绘制在多个图层上，所以在绘制完成后需要将多个图层按照正确的顺序在屏幕上合成，以便最终正确地渲染出来。
这个过程中的每一个阶段都可能产生卡顿，
这里值得说明的是： 并非对于每一帧画面都会经历这五个部分，比如仅修改与绘制相关的属性（文字颜色、背景图片或边缘阴影等），而未对页面布局产生任何修改，那么在计算样式阶段完成后，便会跳过页面布局直接执行绘制。
如果所更改的属性既不影响页面布局又不需要重新绘制，便可直接跳过合成阶段执行。
具体修改哪些属性会触发页面布局、绘制或合成阶段的执行，这与浏览器的内核类型存在一定关系，
不同内核浏览器的 CSS 属性触发差异 属性 Blink Gecko Webkit z-index 绘制/合成 绘制/合成 布局/绘制/合成 transform 合成 合成 布局/绘制/合成 opacity 绘制/合成 合成 布局/绘制/合成 min-width 布局/绘制/合成 布局/合成 布局/绘制/合成 color 布局/绘制 布局/绘制 布局/绘制/合成 background 布局/绘制 布局/绘制 布局/绘制/合成 border-radius 布局/绘制 布局/绘制 布局/绘制/合成 border-style 布局/绘制/合成 布局/绘制/合成 布局/绘制/合成 border-width 布局/绘制/合成 布局/绘制/合成 布局/绘制/合成 JavaScript 执行优化 实现动画效果 利用 JavaScript 通常最容易想到的方式是 setTimeout 或 setInterval 来实现，</description>
    </item>
    
    <item>
      <title>Object.create()</title>
      <link>/posts/49/</link>
      <pubDate>Thu, 14 Sep 2023 14:44:40 +0800</pubDate>
      
      <guid>/posts/49/</guid>
      <description>定义 给对象原型赋值。
Object.create(proto, [propertiesObject]); /* - proto: 新创建对象的原型对象 - propertiesObject: 可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。 */ Object.create() 和 {} 的区别 var o = { a: 1 }; console.log(o); 从上图可以看到，新创建的对象继承了 Object 自身的方法，如 hasOwnProperty、toString 等，在新对象上可以直接使用。
再看看使用 Object.create() 创建对象：
// 创建纯净的对象 var o = Object.create(null, { a: { writable: true, configurable: true, value: &amp;#34;1&amp;#34;, }, }); console.log(o); 可以看到，新创建的对象除了自身属性之外，原型链上没有任何属性，也没有继承 Object 的任何东西，此时如果我们调用 o.toString() 会报 Uncaught TypeError 的错误。
第一个参数是 null，也就是说将 null 设置成了新创建对象的原型。
改改上面的例子：
var o = Object.create( {}, { a: { writable: true, configurable: true, value: &amp;#34;1&amp;#34;, }, } ); console.</description>
    </item>
    
    <item>
      <title>构建优化</title>
      <link>/posts/48/</link>
      <pubDate>Thu, 14 Sep 2023 07:06:22 +0800</pubDate>
      
      <guid>/posts/48/</guid>
      <description>压缩与合并 资源压缩和合并的优点:
减少 http 的请求数量
减少 http 请求的资源大小
HTML 压缩 HTML 压缩的三种方式：
在线网站提供 HTML 压缩服务
基于 nodejs 的工具：html-minifier
const fs = require(&amp;#34;fs&amp;#34;); const { minify } = require(&amp;#34;html-minifier&amp;#34;); fs.readFile(&amp;#34;./test.html&amp;#34;, &amp;#34;utf8&amp;#34;, (err, data) =&amp;gt; { if (err) throw err; fs.writeFile( &amp;#34;./test_mini.html&amp;#34;, minify( data, { removeComments: true, // 去掉注释 collapseWhitespace: true, // 去除空格 minifyJS: true, // 压缩 HTML 中的 JavaScript minifyCSS: true, // 压缩 HTML 中的 css }, () =&amp;gt; console.log(&amp;#34;success&amp;#34;) ) ); }); 服务端模板引擎的渲染压缩 CSS 压缩 CSS 代码也能进行压缩，而且很有必要去压缩。</description>
    </item>
    
    <item>
      <title>书写高性能的代码</title>
      <link>/posts/47/</link>
      <pubDate>Tue, 12 Sep 2023 20:47:00 +0800</pubDate>
      
      <guid>/posts/47/</guid>
      <description>数据存取 数据存取方式 一般而言，Js 的数据存取有 4 种方式：
直接字面量：字面量不存储在特定的位置，也不需要索引，仅仅代表自身，包括 布尔值、数字、字符串、对象、数组、函数、null、undefined 及正则表达式。
变量：通过关键字 const、let、var 定义的数据存储单元。
数组元素：存储在数组对象内部，通过数组下标数字进行索引。
对象属性：存储在对象内部，通过对象的字符串名称进行索引。
其中数组元素和对象属性不仅可以是直接字面量的形式，还可以是其他数组对象或对象属性组成的更为复杂的数据结构。
从读取速度来看，直接字面量与变量是非常快的，相比之下数组元素和对象属性由于需要索引，其读取速度也会因其组成结构的复杂度越高而变的越慢。
作用域和作用域链 JavaScript 只有 全局作用域 和每个函数内部的 局部作用域。
全局作用域 就是无论此时执行的上下文是在函数内部还是函数外部，都能访问到存在于全局作用域中的变量或对象；
而定义存储在函数的 局部作用域 中的对象，只有在该函数内部执行上下文时才能都访问，而对函数外部不可见。
对于能够访问的数据，其在不同作用域中的查询也有 先后顺序。
这就涉及到 作用域链 的概念。
JavaScript 引擎会在页面加载后创建一个全局的作用域，然后每碰到一个要执行的函数，又会为其创建对应的作用域。
最终，不同的 块级作用域 和嵌套在内部的 函数作用域，会形成一个 作用域堆栈。
当前生效的作用域在堆栈的最顶端，由上往下就是当前执行上下文所能访问的作用域链。
举一个简单的例子：
function plus(num) { return num + 1; } const ret = plus(6); 当这段代码刚开始执行时，函数 plus 的作用域中仅拥有一个指向全局对象的作用域，其中包括 this、函数对象 plus 及常量 ret，
而在执行到 plus 时，JavaScript 引擎会创建一个新的执行上下文和包含一些局部变量的活动对象。
执行过程会先对 num 标识符进行解析，即从作用域链的最顶层依次向下查找，直至找到 num 标识符。
实战经验 对局部变量的使用 记住这一条建议：</description>
    </item>
    
    <item>
      <title>资源优先级</title>
      <link>/posts/46/</link>
      <pubDate>Tue, 12 Sep 2023 18:08:38 +0800</pubDate>
      
      <guid>/posts/46/</guid>
      <description>优先级 浏览器基于自身的启发式算法，会对资源的重要性进行判断来划分优先级，通常从低到高为：Lowest、Low、High、Highest。
比如，在 &amp;lt;head&amp;gt; 标签中，CSS 文件通常具有最高的优先级 Highest，其次是 &amp;lt;script&amp;gt; 标签所请求的脚本文件，但当 &amp;lt;script&amp;gt; 标签带有 defer 或 async 的异步属性时，其优先级又会降为 Low。我们呢通过浏览器的控制台可以看到浏览器对资源进行的优先级划分。
预加载 使用 &amp;lt;link rel=&amp;quot;preload&amp;quot;&amp;gt; 标签告诉浏览器当前所指定的资源，应该拥有更高的优先级，例如：
&amp;lt;link rel=&amp;#34;preload&amp;#34; as=&amp;#34;script&amp;#34; href=&amp;#34;important.js&amp;#34; /&amp;gt; &amp;lt;link rel=&amp;#34;preload&amp;#34; as=&amp;#34;style&amp;#34; href=&amp;#34;critical.css&amp;#34; /&amp;gt; 这里通过 as 属性告诉浏览器所要加载的资源类型，
要注意：&amp;lt;link rel=&amp;quot;preload&amp;quot;&amp;gt; 会强制浏览器进行预加载，它与其他资源的提示不同，浏览器对此是必须执行而非可选的。
如果预加载指定的资源在 3s 内未被当前页面使用，则浏览器会在开发者工具的控制台中进行警告提示，该警告务必要处理。
解下来看两个使用实例：字体的使用和关键路径渲染
通常字体文件都位于页面加载的若干个 CSS 文件的末尾，但考虑为了减少用户等待文本内容的加载时间，以及避免系统字体与偏好字体发生冲突，就必须提前获取字体，
&amp;lt;link rel=&amp;#34;preload&amp;#34; as=&amp;#34;font&amp;#34; crossorigin=&amp;#34;crossorigin&amp;#34; type=&amp;#34;font/woff2&amp;#34; href=&amp;#34;myfont.woff2&amp;#34; /&amp;gt; [注]：这里的 crossorigin 属性非常重要，如果缺失该属性，浏览器不会对指定的字体进行预加载。
前面讲过页面渲染生命周期时，提到过关键渲染路径，其中涉及首次渲染之前必须加载的资源（比如 CSS 和 JavaScript 等），这些资源对首屏页面渲染来说是非常重要的。以前通常建议的做法是把这些资源内联到 HTML 中，但对服务端渲染或对页面而言，这样做很容易导致带宽浪费，
所以使用 &amp;lt;link rel=&amp;quot;preload&amp;quot;&amp;gt; 对单个文件进行预加载，除了能很快的请求资源，还能尽量利用缓存，
其唯一的缺点是可能会在浏览器和服务器之间发生额外的往返请求，因为浏览器需要加载解析 HTML 后，才会知道后续资源请求情况，其解决方式可以利用 HTTP2 的推送。</description>
    </item>
    
    <item>
      <title>网站优化之静态资源优化</title>
      <link>/posts/45/</link>
      <pubDate>Tue, 12 Sep 2023 12:19:06 +0800</pubDate>
      
      <guid>/posts/45/</guid>
      <description>1、图片优化细则 1.1 用工具进行图片压缩 压缩 png
node-pngquant-native
跨平台，压缩比高，压缩 png24 非常好。
说明文档：https://www.npmjs.com/package/node-pngquant-native
安装方法：npm install node-pngquant-native
压缩 jpg
jpegtran
跨平台，有 Linux 、Mac、 Windows 的解决方案
官网：http://jpegclub.org/jpegtran/
安装方法：npm install –g jpegtran
使用方法：jpegtran -copy none -optimize -outfile out.jpg in.jpg
压缩 gif
Gifsicle：通过改变每帧比例，减小 gif 文件大小，同时可以使用透明来达到更小的 文件大小，目前公认的解决方案。
安装： http://www.lcdf.org/gifsicle/
使用方式：优化级别设置为不小于 2，1 的话基本不压缩 gifsicle --optimize=3 -o out.gif in.gif
将透明部分截去 gifsicle --optimize=3 --crop-transparency -o out.gif in.gif
1.2 图片尺寸随网络环境变化 不同网络环境（Wifi/4G/3G）下，加载不同尺寸和像素的图片，通过在图片 URL 后 缀加不同参数改变。
http://img13.360buyimg.com/n1/s100x100_jfs/t2443/71/2538811251/470 889/c2ec38b3/570f3438N81a4b62c.jpg
1.3 响应式图片 JavaScript 绑定事件检测窗口大小
CSS 媒体查询 @media screen and (max-width:640px) { my_image{ width:640px; } }</description>
    </item>
    
    <item>
      <title>加载注意事项</title>
      <link>/posts/44/</link>
      <pubDate>Tue, 12 Sep 2023 10:22:36 +0800</pubDate>
      
      <guid>/posts/44/</guid>
      <description>首屏加载 对于首屏上的内容就不应当进行延迟加载，而应该使用正常的加载方式。
此外，若将首屏视窗边界线作为延迟加载触发的阈值，其实并非最贱的性能考虑，更理想的做法是，在延迟加载的媒体资源到达首屏边界之前设置一个缓冲区，以便媒体资源在进入视窗之前就开始进行加载。
代码如下：
const lazyImageObserver = new IntersectionObserver( (entries, onserver) =&amp;gt; { // .... }, { rootMargin: &amp;#34;0 0 256px 0&amp;#34;, } ); 资源占位 当延迟加载的媒体资源未渲染出来之前，应当在页面中使用相同尺寸的占位图，如果不使用占位图，图像延迟显示出来后，尺寸更改可能会使页面布局出现移位。
这种现象不仅会对用户体验带来困惑，更严重的还会触发浏览器成本高昂的回流机制，进而增加系统资源开销，造成卡顿。
而用来占位的图像解决方案也有多种，十分简单的方式是使用一个与目标媒体资源长度相同的纯色占位符，或者之前使用的 Base64 图片，当然也可以采用 LQIP 或 SQIP 等方法。
内容加载失败 在进行延迟加载过程中，可能会因为某种原因造成媒体资源加载失败，进而导致错误的情况。
例如，图片资源可能采用以下方式进行规避：
const newImage = new Image(); newImage.src = &amp;#34;photo.png&amp;#34;; newImage.onerror = (err) =&amp;gt; { // 当发生故障时处理措施 /* 处理措施： 01 可将使用的图片占位图替换为按钮，让用户单击以尝试重新加载所需的媒体资源。 02 或者在占位符区域显示错误的提示信息。 */ }; newImage.onload = () =&amp;gt; { // 加载成功的回调 }; 图像解码延迟 我们知道渐进式的 JPEG 会先呈现一个低像素的图像版本，随后会慢慢呈现出原图的样貌。这是因为图像从被浏览器请求获取，再到最终完整呈现在屏幕上，需要经历一个解码的过程。</description>
    </item>
    
    <item>
      <title>视频加载</title>
      <link>/posts/43/</link>
      <pubDate>Mon, 11 Sep 2023 22:24:25 +0800</pubDate>
      
      <guid>/posts/43/</guid>
      <description>不需要自动播放 为了使页面更快地加载并渲染出来，可以阻止不需要自动播放的视频的预加载，其方法是通过视频标签的 preload 进行控制。
&amp;lt;video controls preload=&amp;#34;none&amp;#34; poster=&amp;#34;default.jpg&amp;#34;&amp;gt; &amp;lt;source src=&amp;#34;simply.webm&amp;#34; type=&amp;#34;video/webm&amp;#34; /&amp;gt; &amp;lt;source src=&amp;#34;simply.mp4&amp;#34; type=&amp;#34;video/mp4&amp;#34; /&amp;gt; &amp;lt;/video&amp;gt; preload 属性通常的默认值是 auto，表示无论用户是否希望，所有视频文件都会被自动下载，这里将其设置为 none，来阻止视频的自动预加载。同时这里还用过 poster 属性为视频提供占位符图片，它的作用是当视频未加载出来时，不至于在页面中呈现一块让用户未知的空白。
浏览器对视频的加载行为可能存在较大的差异：
Chrome 之前的版本中，preload 的默认值是 auto，从 64 版本以后其默认值改为了 metadata，表示仅加载视频的元数据，FireBox、IE11、Edge 等浏览器的行为类似。
Safari 11.0 的 Mac 版会默认进行部分视频资源预加载，11.2 的 Mac 版后仅可预加载元数据，但 ios 的 Safari 不会对视频预加载。
另外，如果你的站点中包含了同一域名下的多个视频资源，最好将 preload 属性设置为 metadata，或者定义 poster 属性值时将 preload 设置为 none，这样能很好的避免 HTTP 的最大连接数，因为通常 HTTP 1.1 协议规定同一域名下的最大连接数为 6，如果同时有超过此数量的资源请求连接，那么多余的连接便会被挂起，这无疑也会对性能造成负面的影响。
视频代替 GIF 动画 应当尽量用视频代替尺寸多大的 GIF 动画，虽然 GIF 动画的应用历史和范围都很广泛，但其在输出文件大小，图像色彩质量等许多方面的表现均不如视频。GIF 动画相对于视频具有三个附加的特性：没有音轨、连续循环播放、加载完成自动播放，替换成视频后类似于：
&amp;lt;video autoplay muted loop playsinline&amp;gt; &amp;lt;source src=&amp;#34;video.</description>
    </item>
    
    <item>
      <title>原生的延迟加载支持</title>
      <link>/posts/42/</link>
      <pubDate>Mon, 11 Sep 2023 21:55:45 +0800</pubDate>
      
      <guid>/posts/42/</guid>
      <description>从 Chrome 75 版本开始，已经可以通过 &amp;lt;img&amp;gt; 和 &amp;lt;iframe&amp;gt; 标签的 loading 属性原生支持延迟加载了，loading 属性包含以下三种取值：
lazy: 进行延迟加载
eager: 立即加载
auto: 浏览器自行决定是否进行延迟加载
若不指定任何属性，loading 默认取值 auto，
&amp;lt;!-- 当用户滚动屏幕视窗到该图像元素时，才进行加载 --&amp;gt; &amp;lt;img src=&amp;#34;photo.jpg&amp;#34; loading=&amp;#34;lazy&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;!-- 立刻加载图像元素 --&amp;gt; &amp;lt;img src=&amp;#34;photo.jpg&amp;#34; loading=&amp;#34;eager&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;!-- 浏览器决定是否进行延迟加载 --&amp;gt; &amp;lt;img src=&amp;#34;photo.jpg&amp;#34; loading=&amp;#34;auto&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;!-- 亦可延迟加载 picture 中的图像 --&amp;gt; &amp;lt;picture&amp;gt; &amp;lt;source media=&amp;#34;(min-width: 750px)&amp;#34; srcset=&amp;#34;phone.jpg 1x, phone-hd.jpg 2x&amp;#34; /&amp;gt; &amp;lt;source srcset=&amp;#34;small.jpg 1x, small- hd.jpg 2x&amp;#34; /&amp;gt; &amp;lt;img src=&amp;#34;default.jpg&amp;#34; loading=&amp;#34;lazy&amp;#34; /&amp;gt; &amp;lt;/picture&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>属性的 getter 和 setter</title>
      <link>/posts/41/</link>
      <pubDate>Mon, 11 Sep 2023 19:34:22 +0800</pubDate>
      
      <guid>/posts/41/</guid>
      <description>有两种类型的对象属性。
第一种是 数据属性。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。
第二种类型的属性是新东西。它是 访问器属性（accessor property）。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。
getter 和 setter 访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 get 和 set 表示：
let obj = { get propName() { // 当读取 obj.propName 时，getter 起作用 }, set propName(value) { // 当执行 obj.propName = value 操作时，setter 起作用 }, }; 当读取 obj.propName 时，getter 起作用，当 obj.propName 被赋值时，setter 起作用。
例如，我们有一个具有 name 和 surname 属性的对象 user：
let user = { name: &amp;#34;John&amp;#34;, surname: &amp;#34;Smith&amp;#34;, }; 现在我们想添加一个 fullName 属性，该属性值应该为 &amp;quot;John Smith&amp;quot;。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：</description>
    </item>
    
    <item>
      <title>裁剪的3种方式，CSS 如何隐藏移动端的滚动条？</title>
      <link>/posts/40/</link>
      <pubDate>Mon, 11 Sep 2023 18:36:17 +0800</pubDate>
      
      <guid>/posts/40/</guid>
      <description>在移动端开发中，经常会碰到需要横向滚动的场景，例如这样的
但很多时候是不需要展示这个滚动条的，也就是这样的效果，如下
你可能想到直接设置滚动条样式就可以了，就像这样
::-webkit-scrollbar { display: none; } 目前来看好像没什么问题，但在某些版本的 iOS 上却无效（具体待测试），滚动条仍然出现。
那有没有其他方式可以解决这个问题呢？下面介绍几个方法
一、通过 overflow 隐藏 既然有时候修改滚动条样式无法解决，我们可以想办法把它隐藏。
下面是一个横向滚动列表
&amp;lt;div class=&amp;#34;list&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 简单修饰一下，让这个列表可以横向滚动
.list { display: flex; overflow: auto; gap: 10px; padding: 10px; } .item { width: 100px; height: 100px; background: royalblue; border-radius: 8px; flex-shrink: 0; } 效果如下
通过 「overflow」 隐藏的方式很简单，我们需要一个父级
&amp;lt;div class=&amp;#34;wrap&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;list&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 然后，将列表底部padding设置的稍微大一些，比如
.list { /**/ padding-bottom: 20px; } 可以看到列表下方的距离变大了，滚动条也更靠下了，效果如下</description>
    </item>
    
    <item>
      <title>当你的网站有新内容，如何立即通知你的用户呢？</title>
      <link>/posts/39/</link>
      <pubDate>Mon, 11 Sep 2023 17:58:59 +0800</pubDate>
      
      <guid>/posts/39/</guid>
      <description>你有没有遇到过这样的场景：当你在浏览网页时，突然收到一个通知，告诉你有新的内容更新，或者有一条重要的消息通知你查看。
作为一枚前端开发，你可能会想，这不就是请求轮询吗？
没错，异步请求通过轮询的方式确实能实现类似的功能，但这不是我们今天要分享的主题 ~
是什么呢？
是 Service Worker！
是的，通过 Service Worker 来实现“推送通知”的功能。Service Worker 是 Web API 的一部分，其功能非常强大。相信通过今天的内容，你肯定会有所收获。
那么现在，就让我们正式开始吧~
1. 初识 Service Worker 简单来说，Service Worker 是一种在浏览器背后默默工作的 JS 脚本，它可以在用户没有打开网页的情况下运行，为网页提供了各种强大的功能，比如离线缓存、后台同步等，当然还有我们今天要分享的——推送通知。
有些网站的推送通知做的相当不错，比如油管（YouTube）。当你关注了油管上的某个 UP 主，当 TA 更新视频后浏览器就会给你推送消息，这时候就算你没有打开浏览器，你也会收到通知。Windows 10 系统上在桌面右下角会弹出一个来自浏览器的消息通知框，通知的内容来自油管那位 UP 主的更新信息；Mac 系统上，在桌面右上角会有一条来自浏览器的通知，通知的内容与 Windows 上的信息一致。
你可能会问，为什么我们要使用 Service Worker 来实现推送通知呢？
原因很简单，因为它可以帮助我们更好地与用户进行交互，能提高用户的参与度，甚至在一定程度上可以提高用户的留存率。设想一下，如果你的网站有新的内容更新，你可以立即通过推送通知告诉你的用户。
这样的话，你的用户就不会错过重要通知了，而通知的内容恰好又戳到了用户的 G 点，那 TA 肯定会点一下消息框，然后瞬间就回到你的网站了。相较于用户首先打开浏览器然后点击书签访问到你的网站来说，这种类似于系统级别的消息通知能极大提高用户粘性。
所以，要不要考虑把 Service Worker 在自己网站上用起来呢？
下面，我们就来一步步实现这个功能。
2. Service Worker 基础 现在你已经对 Service Worker 有了一个基本的了解，接下来我们看一下它的基础知识。
首先你要明白 Service Worker 是如何实现推送通知的。其实它的工作原理也不复杂，当用户访问网页时，Service Worker 就会被安装到用户的设备上。当服务器有新的信息需要传递给用户时，服务器就会发送一个推送事件到 Service Worker。然后，Service Worker 就会接收这个事件推送，并根据这个事件显示给用户一个通知。</description>
    </item>
    
    <item>
      <title>链模式</title>
      <link>/posts/38/</link>
      <pubDate>Mon, 11 Sep 2023 11:06:14 +0800</pubDate>
      
      <guid>/posts/38/</guid>
      <description>通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。
找位助手 var A = function () { return A.fn(); }; A.fn = A.prototype = {}; 获取元素 var A = function (selector) { return A.fn.init(selector); }; A.fn = A.prototype = { init: function (selector) { return document.getElementById(selector); }, length: 2, size: function () { return this.length; }, }; console.log(A(&amp;#34;demo&amp;#34;)); 一个大问题 现在，我还想让 A 对象返回的结果还能够拥有 A.fn 中的方法，如 size 等，现在的设计是办不到的，
var A = function (selector) { return A.fn.init(selector); }; A.fn = A.prototype = { init: function (selector) { // this === A.</description>
    </item>
    
    <item>
      <title>惰性模式</title>
      <link>/posts/37/</link>
      <pubDate>Thu, 07 Sep 2023 22:48:24 +0800</pubDate>
      
      <guid>/posts/37/</guid>
      <description>减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断
对事件的思考 // 单例模式定义命名空间 var A = {}; A.on = function (dom, type, fn) { if (dom.addEventListener) { dom.addEventListener(type, fn, false); } else if (dom.attachEvent) { dom.attachEvent(&amp;#34;on&amp;#34; + type, fn); } else { dom[&amp;#34;on&amp;#34; + type] = fn; } }; 每次为元素添加事件时，总会走一遍能力检测，有点多余。
加载即执行 // 添加绑定事件方法 on A.on = (function (dom, type, fn) { if (document.addEventListener) { return function (dom, type, fn) { dom.addEventListener(type, fn, false); }; } else if (document.attachEvent) { return function (dom, type, fn) { dom.</description>
    </item>
    
    <item>
      <title>简单模板模式</title>
      <link>/posts/36/</link>
      <pubDate>Wed, 06 Sep 2023 14:04:59 +0800</pubDate>
      
      <guid>/posts/36/</guid>
      <description>通过格式化字符串拼凑出视图避免创建视图时大量节点操作，优化内存开销。
实现方案 // 命名空间 var A = A || {}; // 主体展示区容器 A.root = document.getElementById(&amp;#34;conainer&amp;#34;); // 创建视图方法集合 A.strategy = { listPart: function () {}, codePart: function () {}, onlyTitle: function () {}, guide: function () {}, //... }; // 创建视图入口 A.init = function (data) { this.strategy[data.type](data); }; 模板渲染方法
A.formateString = function (str, data) { return str.replace(/\{#(\w+)#\}/g, function (match, key) { return typeof data[key] === undefined ? &amp;#34;&amp;#34; : data[key]; }); }; 有了这个方法，我们可以通过简单模板来渲染出我们需求视图</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>/posts/35/</link>
      <pubDate>Wed, 06 Sep 2023 10:30:47 +0800</pubDate>
      
      <guid>/posts/35/</guid>
      <description>在不暴露对象内部结构的同时，可以顺序的访问聚合对象内部的元素。
迭代器 迭代器就是用来顺序的访问一个聚合对象内部的元素，可以简化遍历操作，
焦点图的例子中，那些图片元素对象其实就是一组聚合对象，然后你要做的就是创建一个迭代器，专门用来访问这些图片数据的，比如前一张、后一张、第一张、最后一张，对每一张图片的处理，对当前图片处理等等。
// 迭代器 var Iterator = function (items, container) { // 父容器 var container = (container &amp;amp;&amp;amp; document.getElementById(container)) || document, // 获取元素 items = container.getElementsByTagName(items), length = items.length, index = 0; // 缓存原生数组的 splice 方法 var splice = [].splice; return { // 获取第一个元素 first: function () {}, // 获取最后一个元素 second: function () {}, // 获取前一个元素 pre: function () {}, // 获取后一个元素 next: function () {}, // 获取某一个元素 get: function () {}, // 对每一个元素执行某一个方法 dealEach: function () {}, // 对某一个元素执行某一个方法 dealItem: function () {}, // 排他方式处理某一个元素 exclusive: function () {}, }; }; 实现迭代器 // 获取第一个元素 first: function() { index = 0; return items[index] }, // 获取最后一个元素 second: function() { index = length - 1; return items[index]; }, // 获取前一个元素 pre: function() { if(--index &amp;gt; 0) { return items[index] } else { index = 0; return null } }, // 获取后一个元素 next: function() { if(++index &amp;lt; length) { return items[index] } else { index = length - 1; return null; } }, // 获取某一个元素 get: function(num) { index = num &amp;gt;= 0 ?</description>
    </item>
    
    <item>
      <title>中介者模式</title>
      <link>/posts/34/</link>
      <pubDate>Wed, 06 Sep 2023 09:59:07 +0800</pubDate>
      
      <guid>/posts/34/</guid>
      <description>通过中介对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合，有时候中介者对象也可以改变对象之间的交互。
中介者模式和观察者模式的区别？ 首先他们都是通过消息的收发机制实现的，不过在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接受者，他们之间信息交流依托于消息系统实现的解耦。而中介者模式中消息的发送方只有一个，就是中介对象，而且中介对象不能订阅消息，只有那些活跃对象（订阅者）才可以订阅中介者的消息，观察者模式需要写一个消息系统，增加了开发成本。
如果使用中介者模式，那么设置层模块对象就应该是一个中介者对象，它负责向各个导航模块对象发送用户设置的消息，而各个导航模块则应该作为消息的订阅者存在。
创建中介者对象 // 中介者对象 var Mediator = function () { // 消息对象 var _msg = {}; return { // 订阅消息方法 register: function (type, action) { // 如果消息存在 if (_msg[type]) { // 存入回调函数 _msg[type].push(action); } else { // 不存在，则建立消息容器 _msg[type] = []; // 存入回调函数 _msg[type].push(action); } }, // 发布消息方法 send: function (type) { // 如果该消息已经被订阅 if (_msg[type]) { for (var i = 0, len = _msg[type].length; i &amp;lt; len; i++) { _msg[type][i] &amp;amp;&amp;amp; _msg[type][i](); } } }, }; }; 试试看，可否一用 // 单元测试 // 订阅消息 Mediator.</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>/posts/33/</link>
      <pubDate>Tue, 05 Sep 2023 21:35:45 +0800</pubDate>
      
      <guid>/posts/33/</guid>
      <description>命令对象 // 模块的实现 var viewCommand = (function () { // 方法集合 var Action = { // 创建方法 create: function () {}, // 展示方法 display: function () {}, }; // 命令接口 return function excute() {}; })(); 视图创建 // 模块的实现 var viewCommand = (function () { var tpl = { product: [ &amp;#34;&amp;lt;div&amp;gt;&amp;#34;, &amp;#39;&amp;lt;img src=&amp;#34;{#src#}&amp;#34;/&amp;gt;&amp;#39;, &amp;#34;&amp;lt;p&amp;gt;{#text#}&amp;lt;/p&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/div&amp;gt;&amp;#34;, ].join(&amp;#34;&amp;#34;), title: [ &amp;#39;&amp;lt;div class=&amp;#34;title&amp;#34;&amp;gt;&amp;#39;, &amp;#39;&amp;lt;div class=&amp;#34;main&amp;#34;&amp;gt;&amp;#39;, &amp;#34;&amp;lt;h2&amp;gt;{#title#}&amp;lt;/h2&amp;gt;&amp;#34;, &amp;#34;&amp;lt;p&amp;gt;{#tips#}&amp;lt;/p&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/div&amp;gt;&amp;#34;, &amp;#34;&amp;lt;/div&amp;gt;&amp;#34;, ].join(&amp;#34;&amp;#34;), }, html = &amp;#34;&amp;#34;; function formateString(str, obj) { return str.</description>
    </item>
    
    <item>
      <title>职责链模式</title>
      <link>/posts/32/</link>
      <pubDate>Tue, 05 Sep 2023 19:33:22 +0800</pubDate>
      
      <guid>/posts/32/</guid>
      <description>解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间传递，直到最后一个对象完成请求的处理。
分解需求 既然一个需求要做很多事情，那就把每件事情独立出一个模块对象去处理，这样完整的需求就被分解成一部分一部分相互独立的模块需求
第一站：请求模块 创建一个异步请求
var sendData = function (data, dealType, dom) { var xhr = new XMLHttpRequest(); var url = &amp;#34;getData.php?mod=userInfo&amp;#34;; xhr.onload = function (event) { if ((xhr.status &amp;gt;= 200 &amp;amp;&amp;amp; xhr.status &amp;lt; 300) || xhr.status === 304) { // 请求成功 dealData(xhr.responseText, dealType, dom); } else { // 请求失败 } }; // 拼接请求字符串 for (var i in data) { url += &amp;#34;&amp;amp;&amp;#34; + i + &amp;#34;=&amp;#34; + data[i]; } // 发送异步请求 xhr.</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>/posts/31/</link>
      <pubDate>Tue, 05 Sep 2023 11:58:20 +0800</pubDate>
      
      <guid>/posts/31/</guid>
      <description>将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定的独立性，不会随客户端变化而变化。
策略对象 // 价格策略 var PriceStrategy = (function () { // 内部算法对象 var strategy = { return30: function (price) { // +price 转化为数字类型 return +price + parseInt(price / 100) * 30; }, return50: function (price) { return +price + parseInt(price / 100) * 50; }, percent90: function (price) { // js 处理小数乘法有 bug return (price * 100 * 90) / 10000; }, percent80: function (price) { return (price * 100 * 80) / 10000; }, percent50: function (price) { return (price * 100 * 50) / 10000; }, }; // 策略算法调用接口 return function (algorithm, price) { return strategy[algorithm] &amp;amp;&amp;amp; strategy[algorithm](price); }; })(); // 使用 var price = PriceStrategy(&amp;#34;return50&amp;#34;, &amp;#34;314.</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>/posts/30/</link>
      <pubDate>Tue, 05 Sep 2023 09:24:15 +0800</pubDate>
      
      <guid>/posts/30/</guid>
      <description>状态对象的实现 var ResultState = function () { var State = { state0: function () { console.log(&amp;#34;这是第一种情况&amp;#34;); }, state1: function () { console.log(&amp;#34;这是第二种情况&amp;#34;); }, state2: function () { console.log(&amp;#34;这是第三种情况&amp;#34;); }, state3: function () { console.log(&amp;#34;这是第四种情况&amp;#34;); }, }; function show(result) { State[&amp;#34;state&amp;#34; + result] &amp;amp;&amp;amp; State[&amp;#34;state&amp;#34; + result](); } return { show, }; }; 状态对象的演练 ResultState.show(3); 状态的优化 // 创建超级玛丽状态类 var MarryState = function () { // 内部状态私有变量 var _currentState = {}, states = { jump: function () { // 跳跃 console.</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>/posts/29/</link>
      <pubDate>Sun, 03 Sep 2023 11:00:57 +0800</pubDate>
      
      <guid>/posts/29/</guid>
      <description>又被称为发布-订阅模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。
我们需要把观察者对象创建出来，他有一个消息容器，和三个方法，分别是订阅消息方法、取消订阅的消息方法、发送订阅消息的方法。
// 将观察者放在闭包中，当页面加载就立即执行 var Observer = (function () { // 防止消息队列暴漏而被篡改故将消息容器作为静态私有变量保存 var _messages = {}; return { // 注册信息接口 regist: function (type, fn) { // 如果消息不存在则应该创建一个该消息类型 if (typeof _messages[type] === &amp;#34;undefined&amp;#34;) { // 将动作推入到该消息对应的动作执行队列中 _messages[type] = [fn]; } else { // 如果信息存在 // 将动作方法推入该消息对应的动作执行序列中 _messages[type].push(fn); } }, // 发布信息接口 fire: function (type, args) { // 如果该消息没有被注册，则返回 if (!_messages[type]) { return; } // 定义消息类型 var events = { type, // 消息类型 args: args || {}, // 消息携带数据 }, i = 0, // 消息动作循环变量 len = _messages[type].</description>
    </item>
    
    <item>
      <title>VSCODE 快捷键</title>
      <link>/posts/28/</link>
      <pubDate>Sun, 03 Sep 2023 09:45:34 +0800</pubDate>
      
      <guid>/posts/28/</guid>
      <description>VSCODE 快捷键 </description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>/posts/27/</link>
      <pubDate>Sat, 02 Sep 2023 18:56:18 +0800</pubDate>
      
      <guid>/posts/27/</guid>
      <description>父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些步骤。
创建基本提示框 首先要做的就是创建一个基本提示框基类，然后其他提示框类只需要在继承基础上，拓展自己所需即可。
// 模板类 基础提示框 data 渲染数据 var Alert = function (data) { // 没有数据则返回，防止后面程序执行 if (!data) { return; } // 设置内容 this.content = data.content; // 创建提示框面板 this.panel = document.createElement(&amp;#34;div&amp;#34;); // 创建提示内容组件 this.contentNode = document.createElement(&amp;#34;p&amp;#34;); // 创建确定按钮组件 this.confirmBtn = document.createElement(&amp;#34;span&amp;#34;); // 创建关闭按钮组件 this.closeBtn = document.createElement(&amp;#34;b&amp;#34;); // 为提示框面板添加类 this.panel.className = &amp;#34;alert&amp;#34;; // 为关闭按钮添加类 this.closeBtn.className = &amp;#34;a-close&amp;#34;; // 为确定按钮添加类 this.confirmBtn.className = &amp;#34;a-confirm&amp;#34;; // 为确定按钮添加文件 this.confirmBtn.innerHTML = data.confirm || &amp;#34;确认&amp;#34;; // 为提示内容添加文本 this.</description>
    </item>
    
    <item>
      <title>reset.css 知多少</title>
      <link>/posts/26/</link>
      <pubDate>Sat, 02 Sep 2023 12:23:14 +0800</pubDate>
      
      <guid>/posts/26/</guid>
      <description>大部分的时候，作为前端，我们在写 CSS 样式之前，都知道需要添加一份 reset.css ，但是有深究过 reset.css 每一句的人恐怕不多，其实其中也是有很多学问的，知己知彼，真正厘清它，对提高 CSS 大有裨益。
reset.css 先来看看早先 YUI 的一个版本的 reset.css，这是一份历史比较悠久的 RESET 方案:
body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, textarea, p, blockquote, th, td { margin: 0; padding: 0; } table { border-collapse: collapse; border-spacing: 0; } fieldset, img { border: 0; } address, caption, cite, code, dfn, em, strong, th, var { font-style: normal; font-weight: normal; } ol, ul { list-style: none; } caption, th { text-align: left; } h1, h2, h3, h4, h5, h6 { font-size: 100%; font-weight: normal; } q:before, q:after { content: &amp;#34;&amp;#34;; } abbr, acronym { border: 0; } 首先，我们要知道 CSS RESET 的目的是什么？是为了消除不同的浏览器在默认样式上不同表现，但是到今天，现代浏览器在这方面的差异已经小了很多。</description>
    </item>
    
    <item>
      <title>现代 CSS 解决方案:CSS 数学函数</title>
      <link>/posts/25/</link>
      <pubDate>Sat, 02 Sep 2023 11:41:00 +0800</pubDate>
      
      <guid>/posts/25/</guid>
      <description>在 CSS 中，其实存在各种各样的函数。具体分为：
Transform functions Math functions Filter functions Color functions Image functions Counter functions Font functions Shape functions Reference functions CSS grid functions 本文，将具体介绍其中的 CSS 数学函数（Math functions）中，已经被浏览器大规模支持的 4 个：
calc() min() max() clamp() 为什么说是被浏览器大规模支持的？因为除了这 4 个目前已经得到大规模支持的数学函数外，其实规范 CSS Values and Units Module Level 4 已经定义了诸如三角函数相关 sin()、cos()、tan() 等，指数函数相关 pow()、sqrt() 等等数学函数，只是目前都处于实验室阶段，还没有浏览器支持它们，需要给时间一点时间。
Calc() calc() 此 CSS 函数允许在声明 CSS 属性值时执行一些计算。
语法类似于
{ width: calc(100% - 80px); } 一些需要注意的点：
+ 和 - 运算符的两边必须要有空白字符。比如，calc(50% -8px) 会被解析成为一个无效的表达式，必须写成calc(8px + -50%) * 和 / 这两个运算符前后不需要空白字符，但如果考虑到统一性，仍然推荐加上空白符 用 0 作除数会使 HTML 解析器抛出异常 涉及自动布局和固定布局的表格中的表列、表列组、表行、表行组和表单元格的宽度和高度百分比的数学表达式，auto 可视为已指定。 calc() 函数支持嵌套，但支持的方式是：把被嵌套的 calc() 函数全当成普通的括号。（所以，函数内直接用括号就好了。） calc() 支持与 CSS 变量混合使用 看一个最常见的例子，页面结构如下：</description>
    </item>
    
    <item>
      <title>21条CSS高级技巧</title>
      <link>/posts/24/</link>
      <pubDate>Sat, 02 Sep 2023 10:59:54 +0800</pubDate>
      
      <guid>/posts/24/</guid>
      <description>使用 CSS 复位 CSS 复位可以在不同的浏览器上保持一致的样式风格。您可以使用 CSS reset 库Normalize等，也可以使用一个更简化的复位方法：
* { box-sizing: border-box; margin: 0; padding: 0; } 现在元素的 margin 和 padding 已为 0，box-sizing可以管理您的 CSS 盒模型布局。 演示 注意：如果你遵循接下来继承 box-sizing讲解的这个技巧, 你不需要在以上代码中添加 box-sizing 属性。
继承 box-sizing 从 html 元素继承 box-sizing ：
html { box-sizing: border-box; } *, *:before, *:after { box-sizing: inherit; } 如此在插件或其它组件里改变 box-sizing 变得简单。
使用 :not() 选择器来决定表单是否显示边框 先为元素添加边框
/* 添加边框 */ .nav li { border-right: 1px solid #666; } 为最后一个元素去除边框
/* 去掉边框 */ .</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>/posts/23/</link>
      <pubDate>Sat, 02 Sep 2023 09:39:55 +0800</pubDate>
      
      <guid>/posts/23/</guid>
      <description>运用共享技术有效的支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。
享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部数据、内部方法指的是相似或者共有的数据和方法，所以将一部分提取出来减少开销。
享元对象 var Flyweight = function () { // 已创建的元素 var created = []; // 创建一个新闻包装容器 function create() { var dom = document.createElement(&amp;#34;div&amp;#34;); // 将容器插入新闻列表容器中 document.getElementById(&amp;#34;container&amp;#34;).appendChild(dom); // 缓存新创建的元素 created.push(dom); // 返回创建的新元素 return dom; } return { // 获取创建新闻元素方法 getDiv: function () { // 如果已创建的元素小于当前页元素的总个数，则创建 if (created.length &amp;lt; 5) { return create(); } else { // 获取第一个元素，并插入最后面 var div = created.shift(); created.push(div); return div; } }, }; }; 实现需求 var paper = 0, num = 5, len = article.</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>/posts/22/</link>
      <pubDate>Thu, 31 Aug 2023 21:34:58 +0800</pubDate>
      
      <guid>/posts/22/</guid>
      <description>每个成员要有祖先 var News = function () { // 子组件容器 this.children = []; // 当前组件元素 this.element = null; }; News.prototype = { // 定义而不是实现 init: function () { throw new Error(&amp;#34;请重写你的方法&amp;#34;); }, // 定义而不是实现 add: function () { throw new Error(&amp;#34;请重写你的方法&amp;#34;); }, // 定义而不是实现 getElement: function () { throw new Error(&amp;#34;请重写你的方法&amp;#34;); }, }; 组合要有容器类 // 容器类构造函数 var Container = function (id, parent) { // 构造函数继承父类 News.call(this); // 模块 id this.id = id; // 模块的父容器 this.</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>/posts/21/</link>
      <pubDate>Wed, 30 Aug 2023 22:06:48 +0800</pubDate>
      
      <guid>/posts/21/</guid>
      <description>多元化对象 // 多维变量类 // 运动单元 function Speed(x, y) { this.x = x; this.y = y; } Speed.prototype.run = function () { console.log(&amp;#34;运动起来&amp;#34;); }; // 着色单元 function Color(cl) { this.color = cl; } Color.prototype.draw = function () { console.log(&amp;#34;绘制色彩&amp;#34;); }; // 变形单元 function Shape(sp) { this.shape = sp; } Shape.prototype.change = function () { console.log(&amp;#34;改变形状&amp;#34;); }; // 说话单元 function Speek(wd) { this.word = wd; } Speek.prototype.say = function () { console.log(&amp;#34;书写字体&amp;#34;); }; 我们想创建一个球类，并且它可以运动，可以着色。</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>/posts/20/</link>
      <pubDate>Wed, 30 Aug 2023 21:55:19 +0800</pubDate>
      
      <guid>/posts/20/</guid>
      <description> 在不改变原对象的基础上，通过对其进行包装拓展使原有对象可以满足用户的更复杂需求。
// 装饰者 var decorator = function (input, fn) { var input = document.getElementById(input); if (typeof input.onclick === &amp;#34;function&amp;#34;) { var oldClickFn = input.onclick; input.onclick = function () { oldClickFn(); fn(); }; } else { input.onclick = fn; } }; // 使用 decorator(&amp;#34;tel_input&amp;#34;, function () { document.getElementById(&amp;#34;tel_demo_text&amp;#34;).style.display = &amp;#34;none&amp;#34;; }); decorator(&amp;#34;name_input&amp;#34;, function () { document.getElementById(&amp;#34;name_demo_text&amp;#34;).style.display = &amp;#34;none&amp;#34;; }); decorator(&amp;#34;address_input&amp;#34;, function () { document.getElementById(&amp;#34;address_demo_text&amp;#34;).style.display = &amp;#34;none&amp;#34;; }); </description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>/posts/19/</link>
      <pubDate>Wed, 30 Aug 2023 21:18:21 +0800</pubDate>
      
      <guid>/posts/19/</guid>
      <description>将一个类（对象）的接口（方法或属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。
以前所写的功能代码 A(function () { A(&amp;#34;button&amp;#34;).on(&amp;#34;click&amp;#34;, function (e) { //... }); }); jQuery 适配器 公司 A 框架代码书写格式是不是与 jQuery 代码书写格式很像，所以需要在加载完 jQuery 框架后写一个适配器，将我们已有的功能适配到 jQuery。适配器主要的任务是适配两种代码库中不兼容的代码，所以首当其冲的就是全局对象 A 与 jQuery 了，所以可以像下面这样轻松的实现。
window.A = A = jQuery; 适配异类框架 公司的整个轻量级 A 框架太像 jQuery 了，我们可以将两种框架看成是相似框架，但是如果一个框架与 jQuery 血缘远一点，那么对于这种异类框架适配情况就复杂多了，举个例子:
// 定义框架 var A = A || {}; A.g = function (id) { return document.getElementById(id); }; // 为元素绑定事件 A.on = function (id, type, fn) { var dom = typeof id === &amp;#34;string&amp;#34; ?</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>/posts/18/</link>
      <pubDate>Wed, 30 Aug 2023 20:47:36 +0800</pubDate>
      
      <guid>/posts/18/</guid>
      <description>添加一个点击事件 document.onclick = function (e) { e.preventDefault(); if (e.target !== document.getElementById(&amp;#34;myinput&amp;#34;)) { hidePageAlert(); } }; function hidePageAlert() { // 隐藏提示框 } 兼容模式 套餐，定制，简化复杂请求，统一封装，外观模式封装
// 外观模式实现 function addEvent(dom, type, fn) { if (dom.addEventListener) { dom.addEventListener(type, fn, false); } else if (dom.attachEvent) { dom.attachEvent(&amp;#34;on&amp;#34; + type, fn); } else { dom[&amp;#34;on&amp;#34; + type] = fn; } } // 使用 var myInput = document.getElementById(&amp;#34;myinput&amp;#34;); addEvent(myInput, &amp;#34;click&amp;#34;, function () { console.log(&amp;#34;绑定第一个事件&amp;#34;); }); addEvent(myInput, &amp;#34;click&amp;#34;, function () { console.</description>
    </item>
    
    <item>
      <title>CSS will-change</title>
      <link>/posts/17/</link>
      <pubDate>Wed, 30 Aug 2023 13:07:35 +0800</pubDate>
      
      <guid>/posts/17/</guid>
      <description>一、什么是 will-change？ will-change是一个 CSS 属性，它可以告诉浏览器某个元素将要发生的变化。通过明确指定这些变化，浏览器可以事先分配和优化相应的资源，从而提升渲染的性能。
二、will-change 的使用方法 要使用will-change，只需将它应用于你要进行性能优化的元素上。
.element { will-change: transform; } 在上述示例中，我们告诉浏览器，该元素即将发生变换（transform），以便浏览器在渲染时提前分配所需的资源。
值得注意的是，因为will-change是为了性能优化而设计的，滥用它可能会带来负面影响。只在需要优化的元素上使用will-change，避免对所有元素都进行指定。
三、will-change 的原理 要理解will-change的原理，我们需要了解浏览器渲染流程的基本概念。
1. 渲染流程简介 浏览器在渲染网页时，会经历一系列的步骤，如样式计算、布局、绘制和合成。为了提高性能，浏览器会尽量避免进行不必要的计算和操作。
2. will-change 的作用 will-change的作用就是告诉浏览器某个元素将要发生的变化，从而使浏览器在渲染过程中提前分配和优化相应的资源。
例如，当我们设置了will-change: transform时，浏览器会为该元素创建一个独立的图层，将这个图层标记为“即将变换”。这样，在进行布局和绘制时，浏览器就可以更高效地处理这个元素，而无需重新计算整个渲染树。
加入 will-change 后，通过观察复合层，如图下
加入 will-change 后，元素会被提升到单独的复合层，动画（重绘、重排）的操作只会在单独复合层上进行，减少了原来的页面层重绘和重排的行为 注：每一个元素单独加入 will-change 都会单独创建一个复合层，如果给大量的元素加上 will-change 就会创建大量的复合层，反而会影响性能
3. will-change的优化效果 使用will-change可以带来以下优化效果：
减少渲染阻塞：浏览器可以提前分配和优化资源，减少渲染阻塞时间，提高页面的响应速度。 减少重绘和重排：浏览器可以更好地管理渲染过程，避免不必要的重绘和重排，从而提高渲染性能。 硬件加速：某些浏览器对will-change属性会进行硬件加速，进一步提升性能。 4. will-change使用的时机 在很多关于 will-change 的描述，都能够看到类似下面的一段话
在实际更改的元素上将 will-change 设置为您将实际更改的属性。并在他们停止时将其删除。- Tab Atkins Jr.（规范编辑者）
至于为什么？大部分的描述都是因为 will-change 会消耗浏览器 GPU 资源
当元素有 will-change 时，将元素提升到它们自己的“GPU 层”的浏览器。但有太多元素声明时，浏览器将忽略声明，以避免耗尽 GPU 内存
所以对于 will-change 的使用应该控制时机
在适当的时机移除 will-change 就是减少浏览器的复合层，避免过度使用 will-change 带来性能问题</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>/posts/16/</link>
      <pubDate>Tue, 29 Aug 2023 21:32:16 +0800</pubDate>
      
      <guid>/posts/16/</guid>
      <description>单例模式：是只允许实例化一次的对象类。
命名空间的管理员 单例模式常用来定义命名空间
var Ming = { g: function (id) { return document.getElementById(id); }, css: function (id, key, value) { this.g(id).style[key] = value; }, }; 模块分明 单例模式除了定义命名空间外，还有一个作用，就是通过单例模式来管理代码库的各个模块，
baidu.dom.addClass #添加元素类 baidu.dom.append #插入元素 baidu.event.stopPropagation #阻止冒泡 baidu.event.preventDefault #阻止默认行为 baidu.event.trim #去除字符串收尾空白符 baidu.string.encodeHTML #将字符串进行html编码 创建一个小型代码库 我们也可以用单例模式来规范我们自己代码库的各个模块，比如我们有一个 A 库，它包含公用模块、工具模块、ajax 模块和其他模块，我们就可以自己定制一个如下的小型代码库。
var A = { Util: { util_method1: function () {}, util_method2: function () {}, //... }, Tool: { tool_method1: function () {}, tool_method2: function () {}, //.</description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>/posts/15/</link>
      <pubDate>Tue, 29 Aug 2023 17:16:23 +0800</pubDate>
      
      <guid>/posts/15/</guid>
      <description>创建一个焦点图 假设页面中有很多焦点图，那么我们要实现这些焦点图最好的方式就是通过创建对象来一一实现。我们就需要有一个焦点类，比如我们把这个类定义为 LoopImages。
// 图片轮播类 var LoopImages = function (imgArr, container) { this.imagesArray = imgArr; this.container = container; this.createImage = function () {}; this.changeImage = function () {}; }; 如果一个页面中有多个焦点图，其切换动画一般是多样化的，有的可能是上下切换，有的可能是左右切换，有的可能是渐隐渐现，有的可能是放缩切换，等等。因此创建的轮播图片结构应该是多样化的，同样切换的效果也应该是多样化的，因此我们应该抽象出一个基类，让不同特效去继承这个基类，然后对于差异化的需求通过重写这些继承下来的属性或方法来解决。
比如，有一个包含左右切换箭头，如下：
// 上下滑动切换类 var SlideLoopImg = function (imgArr, container) { LoopImages.call(this, imgArr, container); this.changeImage = function () { console.log(&amp;#34;SlideLoopImg changeImage function&amp;#34;); }; }; // 渐隐切换类 var FadeLoopImg = function (imgArr, container, arrow) { LoopImages.call(this, imgArr, container); this.arrow = arrow; this.changeImage = function () { console.</description>
    </item>
    
    <item>
      <title>前端异常监控解决方案研究</title>
      <link>/posts/14/</link>
      <pubDate>Tue, 29 Aug 2023 17:05:52 +0800</pubDate>
      
      <guid>/posts/14/</guid>
      <description>前端监控包括行为监控、异常监控、性能监控等，本文主要讨论异常监控。对于前端而言，和后端处于同一个监控系统中，前端有自己的监控方案，后端也有自己等监控方案，但两者并不分离，因为一个用户在操作应用过程中如果出现异常，有可能是前端引起，也有可能是后端引起，需要有一个机制，将前后端串联起来，使监控本身统一于监控系统。因此，即使只讨论前端异常监控，其实也不能严格区分前后端界限，而要根据实际系统的设计，在最终的报表中体现出监控对开发和业务的帮助。
一般而言，一个监控系统，大致可以分为四个阶段：日志采集、日志存储、统计与分析、报告和警告。
采集阶段：收集异常日志，先在本地做一定的处理，采取一定的方案上报到服务器。
存储阶段：后端接收前端上报的异常日志，经过一定处理，按照一定的存储方案存储。
分析阶段：分为机器自动分析和人工分析。机器自动分析，通过预设的条件和算法，对存储的日志信息进行统计和筛选，发现问题，触发报警。人工分析，通过提供一个可视化的数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常问题根源。
报警阶段：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。
1 前端异常 前端异常是指在用户使用 Web 应用时无法快速得到符合预期结果的情况，不同的异常带来的后果程度不同，轻则引起用户使用不悦，重则导致产品无法使用，使用户丧失对产品的认可。
1.1 前端异常分类 根据异常代码的后果的程度，对前端异常的表现分为如下几类
a. 出错
界面呈现的内容与用户预期的内容不符，例如点击进入非目标界面，数据不准确，出现的错误提示不可理解，界面错位，提交后跳转到错误界面等情况。这类异常出现时，虽然产品本身功能还能正常使用，但用户无法达成自己目标。
b. 呆滞
界面出现操作后没有反应的现象，例如点击按钮无法提交，提示成功后无法继续操作。这类异常出现时，产品已经存在界面级局部不可用现象。
c. 损坏
界面出现无法实现操作目的的现象，例如点击无法进入目标界面，点击无法查看详情内容等。这类异常出现时，应用部分功能无法被正常使用。
d. 假死
界面出现卡顿，无法对任何功能进行使用的现象。例如用户无法登陆导致无法使用应用内功能，由于某个遮罩层阻挡且不可关闭导致无法进行任何后续操作。这类异常出现时，用户很可能杀死应用。
e. 崩溃
应用出现经常性自动退出或无法操作的现象。例如间歇性 crash，网页无法正常加载或加载后无法进行任何操作。这类异常持续出现，将直接导致用户流失，影响产品生命力。
1.2 异常错误原因分类 前端产生异常的原因主要分 5 类：
原因案例频率逻辑错误1) 业务逻辑判断条件错误
2) 事件绑定顺序错误
3) 调用栈时序错误
4) 错误的操作js对象经常数据类型错误1) 将null视作对象读取property
2) 将undefined视作数组进行遍历
3) 将字符串形式的数字直接用于加运算
4) 函数参数未传经常语法句法错误较少网络错误1) 慢
2) 服务端未返回数据但仍200，前端按正常进行数据遍历
3) 提交数据时网络中断
4) 服务端500错误时前端未做任何错误处理偶尔系统错误1) 内存不够用
2) 磁盘塞满
3) 壳不支持API
4) 不兼容较少2 异常采集 2.1 采集内容 当异常出现的时候，我们需要知道异常的具体信息，根据异常的具体信息来决定采用什么样的解决方案。在采集异常信息时，可以遵循 4W 原则：</description>
    </item>
    
    <item>
      <title>JS错误监控篇</title>
      <link>/posts/13/</link>
      <pubDate>Tue, 29 Aug 2023 16:59:15 +0800</pubDate>
      
      <guid>/posts/13/</guid>
      <description>监控流程：监控并收集错误 -&amp;gt; 存储并上报错误 -&amp;gt; 分析并聚合错误 -&amp;gt; 发送错误报警-&amp;gt; 定位并解决 JS 错误
一、监控并收集 Javascript 错误 众所周知，我们是有办法去监听前端 Js 错误的，他们分别 window.onerror、window.onunhandledrejection、console.error 方法。
通过这些方法能够为我们记录下线上的运行时错误，以及详细的堆栈信息。我将 window.onerror(捕获异常)，console.error(自定义异常) 方法收集到的错误信息进行分析统计后的效果如下：
（1）重写 window.onerror 方法 // 重写 onerror 进行jsError的监听 window.onerror = function (errorMsg, url, lineNumber, columnNumber, errorObj) { var errorStack = errorObj ? errorObj.stack : null; siftAndMakeUpMessage( &amp;#34;on_error&amp;#34;, errorMsg, url, lineNumber, columnNumber, errorStack ); }; window.onerror 方法以及它的参数我就不一一介绍了，我相信大家也已经耳熟能详了；我们记录下错误发生时的行、列号，以及错误堆栈。
（2）重写 window.onunhandledrejection 方法 window.onunhandledrejection = function (e) { var errorMsg = &amp;#34;&amp;#34;; var errorStack = &amp;#34;&amp;#34;; if (typeof e.</description>
    </item>
    
    <item>
      <title>前端异常处理最佳实践</title>
      <link>/posts/12/</link>
      <pubDate>Tue, 29 Aug 2023 16:27:16 +0800</pubDate>
      
      <guid>/posts/12/</guid>
      <description>前端可以说是最贴近用户的一层，当产品不断的迭代完善，产品的用户体验会更加趋向于完美，然而前端异常却是很另人头疼的一个问题，我们应该怎么去对待这些异常呢？
一、为什么要处理异常？
异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。
增强用户体验； 远程定位问题； 未雨绸缪，及早发现问题； 无法复线问题，尤其是移动端，机型，系统都是问题； 完善的前端方案，前端监控系统； 对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。
二、需要处理哪些异常？
对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：
JS 语法错误、代码异常 AJAX 请求异常 静态资源加载异常 Promise 异常 Iframe 异常 跨域 Script error 崩溃和卡顿 下面我会针对每种具体情况来说明如何处理这些异常。
三、Try-Catch 的误区
try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。
1、同步运行时错误：
输出：
2、不能捕获到语法错误，我们修改一下代码，删掉一个单引号：
输出：
不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。
3、异步错误
可以看看日志：
并没有捕获到异常，这是需要我们特别注意的地方。
四、window.onerror 不是万能的
当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。
1、首先试试同步运行时错误
可以看到，我们捕获到了异常：
2、再试试语法错误呢？
控制台打印出了这样的异常：
竟然没有捕获到语法错误？
3、怀着忐忑的心，我们最后来试试异步运行时错误：
控制台输出了：
4、接着，我们试试网络请求异常的情况：
我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。
补充一点： window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx
控制台就不会再有这样的错误了：</description>
    </item>
    
    <item>
      <title>高效加载第三方JavaScript</title>
      <link>/posts/11/</link>
      <pubDate>Tue, 29 Aug 2023 16:16:21 +0800</pubDate>
      
      <guid>/posts/11/</guid>
      <description>如果第三方脚本降低您的页面加载速度，您有两个选项可以提高性能：
如果它没有为您的网站增加明确的价值，请将其删除。 优化加载过程。 本文解释如何使用以下技术优化第三方脚本的加载过程：
针对 &amp;lt;script&amp;gt; 标记使用 async 或 defer 属性 建立与所需来源的早期连接 延迟加载 优化您使用第三方脚本的方式 使用 async 或 defer 由于同步脚本会延迟 DOM 构建和呈现，因此您应该始终异步加载第三方脚本，除非脚本必须在页面呈现之前运行。
async 和 defer 属性告诉浏览器其可以在后台加载脚本时继续解析 HTML，然后在加载后执行脚本。这样，脚本下载不会阻止 DOM 构建和页面呈现。这样，用户就可以在所有脚本加载完成之前看到页面。
&amp;lt;script async src=&amp;#34;script.js&amp;#34;&amp;gt; &amp;lt;script defer src=&amp;#34;script.js&amp;#34;&amp;gt; async 和 defer 之间的区别在于它们何时开始执行脚本。
async 具有 async 属性的脚本在完成下载后和窗口加载事件之前第一时间执行。这意味着 async 脚本可能（并且很可能）不会按照它们在 HTML 中出现的顺序执行。这也意味着如果它们在解析器仍在工作时完成下载，他们可以中断 DOM 构建。
defer 具有 defer 属性的脚本在 HTML 解析完全完成之后执行，但在 DOMContentLoaded 事件之前执行。defer 保证脚本将按照它们在 HTML 中出现的顺序执行并且不会阻塞解析器。
如果在加载过程中更早地运行脚本很重要，请使用 async。 对不太重要的资源使用 defer。例如，低于首屏的视频播放器。 使用这些属性可以显著加快页面加载速度。例如，Telegraph 最近推迟了所有脚本，包括广告和分析，并将广告加载时间平均缩短了四秒。
分析脚本通常会提前加载，因此您不会错过任何有价值的分析数据。幸运的是，有一些模式可以在保留早期页面加载数据的同时延迟初始化分析。
建立与所需来源的早期联系 通过与重要的第三方来源建立早期连接，您可以节省 100–500 毫秒。</description>
    </item>
    
    <item>
      <title>ES6到ES12常用新特性</title>
      <link>/posts/10/</link>
      <pubDate>Tue, 29 Aug 2023 10:14:46 +0800</pubDate>
      
      <guid>/posts/10/</guid>
      <description>ES 是什么？ ES 是 ECMAScript 的缩写，也就是 JavaScript 的标准化规范。ECMAScript 是一种由 Ecma 国际组织制定的脚本语言标准，它定义了 JavaScript 的语法、类型、操作符、对象和函数等基本组件。ES6（也称为 ES2015）是 ECMAScript 的第六个版本，引入了许多新的语言特性和改进，如箭头函数、模板字面量、解构赋值等。随后的版本（如 ES7、ES8 等）也引入了许多新的功能和语法糖，以进一步改进和扩展 JavaScript。
各版本特性总结 版本 特性 描述 ES6 let 和 const 关键字 引入了块级作用域声明变量的关键字 let 和常量声明变量的关键字 const ES6 函数参数默认值 允许在函数定义时为参数设置默认值 ES6 箭头函数 使用箭头 (=&amp;gt;) 定义函数，简化了函数的写法，并且自动绑定了当前作用域的 this ES6 模板字符串 使用反引号 (`) 来定义字符串，可以在字符串中插入变量或表达式，并支持多行字符串 ES6 扩展操作符 使用扩展操作符 (&amp;hellip;) 可以将数组或对象展开为单独的元素 ES6 解构赋值 可以从数组或对象中提取值并赋给变量 ES6 对象字面量简化 简化了对象的定义和属性的赋值方式 ES6 类 引入了类和继承的概念，使得 JavaScript 更像面向对象编程语言 ES6 模块化 支持使用 import 和 export 关键字进行模块化开发，可以方便地导入和导出模块 ES6 Promise 提供了一种更优雅的方式来处理异步操作，解决了回调地狱的问题 ES6 Symbol 引入了一种新的原始数据类型 Symbol，可以用来创建唯一的标识符 ES6 Map/WeakMap 和 Set/WeakSet 数据结构 提供了更灵活和高效的数据结构，Map 是一种键值对的集合，Set 是一种无重复值的集合，WeakMap 和 WeakSet 是弱引用版本，可以更好地处理内存和垃圾回收的问题 ES6 迭代器（Iterator）和 for&amp;hellip;of 迭代器提供了一种遍历集合的方式，for&amp;hellip;of 循环可以直接遍历可迭代对象 ES6 生成器（Generator） 可以生成多个值的函数，使用 function* 和 yield 关键字定义，可以暂停和恢复函数的执行 ES6 Proxy 提供了拦截和自定义操作的机制，可以代理对目标对象的访问和修改操作 ES6 Reflect 提供了一组静态方法来操作对象，比如获取对象的属性描述符、动态调用对象的方法等 ES6 数组对象扩展 引入了一些新的方法和属性，比如 Array.</description>
    </item>
    
    <item>
      <title>50个JS高级知识点</title>
      <link>/posts/09/</link>
      <pubDate>Tue, 29 Aug 2023 09:30:43 +0800</pubDate>
      
      <guid>/posts/09/</guid>
      <description>知识点 1、undeclared 与 undefined 的区别？ undefined：声明了变量，但是没有赋值 undeclared：没有声明变量就直接使用 var a; //undefined b; // b is not defined 2、let &amp;amp; const 与 var 的区别？ var 存在变量提升，可重复声明同一变量，声明的变量均可改 let 没有变量提升，不可重复声明同一变量，声明的变量均可改 const 没有变量提升，不可重复声明同一变量，声明的基本数据类型不可改，引用类型可改属性，不可只声明变量而不赋值 3、暂时性死区问题 var a = 100; if (1) { a = 10; //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a， // 而这时，还未到声明时候，所以控制台Error:a is not defined let a = 1; } 4、获取 DOM 元素有哪些方法 方法 描述 返回类型 document.getElementById(id) 通过 id 获取 dom 符合条件的 dom 对象 document.getElementsByTagName(tagName) 通过标签名获取 dom 符合条件的所有 dom 对象组成的类数组 document.</description>
    </item>
    
    <item>
      <title>真正理解Promise</title>
      <link>/posts/08/</link>
      <pubDate>Sun, 27 Aug 2023 22:32:16 +0800</pubDate>
      
      <guid>/posts/08/</guid>
      <description>Promise 的简单介绍 Promise 是用来进行异步编程的。在 Promise 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&amp;#34;load&amp;#34;, function (data) { console.log(data); }); xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr.send(); 这种方式有一个致命的缺点，那就是回调地狱，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&amp;#34;load&amp;#34;, function (data) { console.log(data); const xhr1 = new XMLHttpRequest(); xhr1.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr1.send(); xhr1.addEventListener(&amp;#34;load&amp;#34;, function (data1) { console.log(data1); //... 发送第三个请求 }); }); xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr.send(); 这种代码不仅看起来很痛苦，写起来也非常痛苦。而 Promise 就是用来解决这个问题的，可以把 Promise 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态改变只有两种：从 pending 变为 fulfilled 或从 pending 变为 rejected ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 resolve 函数使得状态变为 fulfilled，reject 函数使得状态变为 rejected。</description>
    </item>
    
    <item>
      <title>10种JavaScript快乐写法</title>
      <link>/posts/07/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:42 +0800</pubDate>
      
      <guid>/posts/07/</guid>
      <description>数组去重 方式一 const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = Array.from(new Set(arr)); // const uniqueArr = [...new Set(arr)]; 方式二 const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = []; arr.forEach((item) =&amp;gt; { // 或者!uniqueArr.includes(item) if (uniqueArr.indexOf(item) === -1) { uniqueArr.push(item); } }); const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = arr.filter((item, index) =&amp;gt; { return arr.</description>
    </item>
    
    <item>
      <title>建造者模式</title>
      <link>/posts/06/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:40 +0800</pubDate>
      
      <guid>/posts/06/</guid>
      <description>建造者模式：将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不用的表示。
创建对象的另一种形式 // 创建一位人类 var Human = function (param) { // 技能 this.skill = (param &amp;amp;&amp;amp; param.skill) || &amp;#34;保密&amp;#34;; // 兴趣爱好 this.hobby = (param &amp;amp;&amp;amp; param.hobby) || &amp;#34;保密&amp;#34;; }; // 类人原型方法 Human.prototype = { getSkill: function () { return this.skill; }, getHobby: function () { return this.hobby; }, }; // 实例化姓名类 var Named = function (name) { var that = this; // 构造器 // 构造函数解析姓名的姓与名 (function (name, that) { that.</description>
    </item>
    
    <item>
      <title>抽象工厂模式</title>
      <link>/posts/05/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:37 +0800</pubDate>
      
      <guid>/posts/05/</guid>
      <description>抽象类 是一种声明了但不能使用的类，当你使用的时候就会报错。
// 汽车抽象类，当使用其实例对象的方法时会抛出错误 var Car = function () {}; Car.prototype = { getPrice: function () { return new Error(&amp;#34;抽象方法不能调用&amp;#34;); }, getSpeed: function () { return new Error(&amp;#34;抽象方法不能调用&amp;#34;); }, }; 如上，创建这个 Car 类其实什么都不用做，创建时没有任何属性，然后其原型上方法也不能使用，否则会报错。但在继承上很有用，因为定义了一种类，并定义了该类所必备的方法，如果在子类中没有重写这些方法，那调用的时候就会报错。
抽象工厂模式 直接赋值是无法实现正确的继承关系的。如果直接将子类的原型设置为父类的实例，那么子类的原型对象将直接引用父类的实例对象，这样在修改子类的原型时会直接影响到父类的实例。而使用 F 函数作为中转，可以通过 F 函数的实例来实现子类对父类的继承，同时保持子类和父类的独立性，避免相互影响。这样子类可以自由地修改自己的原型对象，而不会影响到父类或其他子类的实例。因此，使用 F 函数作为中转是为了正确实现继承关系和保持对象的独立性。
// 抽象工厂方法 var VehicleFactory = function (subType, superType) { // 判断抽象工厂中是否有该抽象类 if (typeof VehicleFactory[superType] === &amp;#34;function&amp;#34;) { // 缓存类 function F() {} // 继承父类属性和方法 F.prototype = new VehicleFactory[superType](); // 将子类 constructor 指向子类 superType.</description>
    </item>
    
    <item>
      <title>ES2016到ES2023新特性</title>
      <link>/posts/04/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:35 +0800</pubDate>
      
      <guid>/posts/04/</guid>
      <description>ES2016 Array.prototype.includes() 这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false
// 我有一个水果篮子 const fruitBasket = [&amp;#34;apple&amp;#34;, &amp;#34;banana&amp;#34;, &amp;#34;orange&amp;#34;, &amp;#34;grape&amp;#34;]; // 我要检查篮子里是否有橙子 const hasOrange = fruitBasket.includes(&amp;#34;orange&amp;#34;); console.log(hasOrange); // 输出: true // 我还想知道篮子里是否有葡萄 const hasGrape = fruitBasket.includes(&amp;#34;grape&amp;#34;); console.log(hasGrape); // 输出: true // 现在我要检查篮子里是否有西瓜 const hasWatermelon = fruitBasket.includes(&amp;#34;watermelon&amp;#34;); console.log(hasWatermelon); // 输出: false 求幂运算符 求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂
// 我要计算 2 的 3 次幂 const result = 2 ** 3; console.log(result); // 输出: 8 ES2017 Object.values / Object.entries const person = { name: &amp;#34;Alice&amp;#34;, age: 25, city: &amp;#34;New York&amp;#34;, }; const values = Object.</description>
    </item>
    
    <item>
      <title>工厂方法模式</title>
      <link>/posts/03/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:33 +0800</pubDate>
      
      <guid>/posts/03/</guid>
      <description>安全工厂方法 // 安全模式创建的工厂类 var Factory = function (type, content) { if (this instanceof Factory) { var s = new this[type](content); return s; } else { return new Factory(type, content); } }; // 工厂原型中设置创建所有类型数据对象的基类 Factory.prototype = { Java: function (content) { //... }, JavaScript: function (content) { //... }, UI: function (content) { this.content = content; (function (content) { var div = document.createElement(&amp;#34;div&amp;#34;); div.innerHTML = content; div.style.border = &amp;#34;1px solid red&amp;#34;; document.</description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>/posts/02/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:30 +0800</pubDate>
      
      <guid>/posts/02/</guid>
      <description>又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建用一类对象。
工作中的一次需求 var LoginAlert = function (text) { this.content = text; }; LoginAlert.prototype.show = function () { // 显示警示框 }; var userNameAlert = new LoginAlert(&amp;#34;用户名不能多于 16 个字母或数字&amp;#34;); userNameAlert.show(); 上面的类，如果对于多种场景，就不那么适用了；可能要需要定义多个类。
如果类太多，那么提供一个 // 篮球基类 var Basketball = function () { this.intro = &amp;#34;篮球盛行于美国&amp;#34;; }; Basketball.prototype = { getMember: function () { console.log(&amp;#34;每个队伍需要5名队员&amp;#34;); }, getBallSize: function () { console.log(&amp;#34;篮球很大&amp;#34;); }, }; // 足球基类 var Football = function () { this.intro = &amp;#34;足球在世界范围内很流行&amp;#34;; }; Football.</description>
    </item>
    
    <item>
      <title>面向对象编程</title>
      <link>/posts/01/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:28 +0800</pubDate>
      
      <guid>/posts/01/</guid>
      <description>封装 创建一个类 var Book = function (id, bookname, price) { this.id = id; this.bookname = bookname; this.price = price; }; 也可以通过在类的原型上添加属性和方法 Book.prototype.display = function () { // 展示这本书 }; // 或者 Book.prototype = { display: function () { // 展示这本书 }, }; 实例化使用类 var book = new Book(10, &amp;#34;JavaScript 设计模式&amp;#34;, 50); console.log(book.bookname); 属性与方法封装 var Book = function (id, name, price) { // 私有属性 var num = 1; // 私有方法 function checkId() {} // 特权方法 this.</description>
    </item>
    
  </channel>
</rss>
