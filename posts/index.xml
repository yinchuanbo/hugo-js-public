<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 灏天阁</title>
    <link>/posts/</link>
    <description>Recent content in Posts on 灏天阁</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2008–2019, Steve Francia and the lee.so; all rights reserved.</copyright>
    <lastBuildDate>Tue, 29 Aug 2023 10:14:46 +0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ES6到ES12常用新特性</title>
      <link>/posts/10/</link>
      <pubDate>Tue, 29 Aug 2023 10:14:46 +0800</pubDate>
      
      <guid>/posts/10/</guid>
      <description>ES 是什么？ ES 是 ECMAScript 的缩写，也就是 JavaScript 的标准化规范。ECMAScript 是一种由 Ecma 国际组织制定的脚本语言标准，它定义了 JavaScript 的语法、类型、操作符、对象和函数等基本组件。ES6（也称为 ES2015）是 ECMAScript 的第六个版本，引入了许多新的语言特性和改进，如箭头函数、模板字面量、解构赋值等。随后的版本（如 ES7、ES8 等）也引入了许多新的功能和语法糖，以进一步改进和扩展 JavaScript。
各版本特性总结 版本 特性 描述 ES6 let 和 const 关键字 引入了块级作用域声明变量的关键字 let 和常量声明变量的关键字 const ES6 函数参数默认值 允许在函数定义时为参数设置默认值 ES6 箭头函数 使用箭头 (=&amp;gt;) 定义函数，简化了函数的写法，并且自动绑定了当前作用域的 this ES6 模板字符串 使用反引号 (`) 来定义字符串，可以在字符串中插入变量或表达式，并支持多行字符串 ES6 扩展操作符 使用扩展操作符 (&amp;hellip;) 可以将数组或对象展开为单独的元素 ES6 解构赋值 可以从数组或对象中提取值并赋给变量 ES6 对象字面量简化 简化了对象的定义和属性的赋值方式 ES6 类 引入了类和继承的概念，使得 JavaScript 更像面向对象编程语言 ES6 模块化 支持使用 import 和 export 关键字进行模块化开发，可以方便地导入和导出模块 ES6 Promise 提供了一种更优雅的方式来处理异步操作，解决了回调地狱的问题 ES6 Symbol 引入了一种新的原始数据类型 Symbol，可以用来创建唯一的标识符 ES6 Map/WeakMap 和 Set/WeakSet 数据结构 提供了更灵活和高效的数据结构，Map 是一种键值对的集合，Set 是一种无重复值的集合，WeakMap 和 WeakSet 是弱引用版本，可以更好地处理内存和垃圾回收的问题 ES6 迭代器（Iterator）和 for&amp;hellip;of 迭代器提供了一种遍历集合的方式，for&amp;hellip;of 循环可以直接遍历可迭代对象 ES6 生成器（Generator） 可以生成多个值的函数，使用 function* 和 yield 关键字定义，可以暂停和恢复函数的执行 ES6 Proxy 提供了拦截和自定义操作的机制，可以代理对目标对象的访问和修改操作 ES6 Reflect 提供了一组静态方法来操作对象，比如获取对象的属性描述符、动态调用对象的方法等 ES6 数组对象扩展 引入了一些新的方法和属性，比如 Array.</description>
    </item>
    
    <item>
      <title>50个JS高级知识点</title>
      <link>/posts/09/</link>
      <pubDate>Tue, 29 Aug 2023 09:30:43 +0800</pubDate>
      
      <guid>/posts/09/</guid>
      <description>知识点 1、undeclared 与 undefined 的区别？ undefined：声明了变量，但是没有赋值 undeclared：没有声明变量就直接使用 var a; //undefined b; // b is not defined 2、let &amp;amp; const 与 var 的区别？ var 存在变量提升，可重复声明同一变量，声明的变量均可改 let 没有变量提升，不可重复声明同一变量，声明的变量均可改 const 没有变量提升，不可重复声明同一变量，声明的基本数据类型不可改，引用类型可改属性，不可只声明变量而不赋值 3、暂时性死区问题 var a = 100; if (1) { a = 10; //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a， // 而这时，还未到声明时候，所以控制台Error:a is not defined let a = 1; } 4、获取 DOM 元素有哪些方法 方法 描述 返回类型 document.getElementById(id) 通过 id 获取 dom 符合条件的 dom 对象 document.getElementsByTagName(tagName) 通过标签名获取 dom 符合条件的所有 dom 对象组成的类数组 document.</description>
    </item>
    
    <item>
      <title>真正理解Promise</title>
      <link>/posts/08/</link>
      <pubDate>Sun, 27 Aug 2023 22:32:16 +0800</pubDate>
      
      <guid>/posts/08/</guid>
      <description>Promise 的简单介绍 Promise 是用来进行异步编程的。在 Promise 出现之前，传统的异步编程靠的是监听事件和回调函数，比如：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&amp;#34;load&amp;#34;, function (data) { console.log(data); }); xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr.send(); 这种方式有一个致命的缺点，那就是回调地狱，如果我们想在第一个请求成功返回数据之后，再发送第二个请求，那就只能在第一个请求成功的回调函数中发送，以此类推，还想再发送下一个请求时，就只能在上一个请求成功的回调函数中发送：
const xhr = new XMLHttpRequest(); xhr.addEventListener(&amp;#34;load&amp;#34;, function (data) { console.log(data); const xhr1 = new XMLHttpRequest(); xhr1.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr1.send(); xhr1.addEventListener(&amp;#34;load&amp;#34;, function (data1) { console.log(data1); //... 发送第三个请求 }); }); xhr.open(&amp;#34;GET&amp;#34;, &amp;#34;http://www.example.com/&amp;#34;); xhr.send(); 这种代码不仅看起来很痛苦，写起来也非常痛苦。而 Promise 就是用来解决这个问题的，可以把 Promise 理解成一个容器，里面保存着某个未来才会结束的事件的结果（也就是异步操作的结果），它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败），状态改变只有两种：从 pending 变为 fulfilled 或从 pending 变为 rejected ，一旦状态改变，就不会再变了。一般情况下，可以分别通过 resolve 函数使得状态变为 fulfilled，reject 函数使得状态变为 rejected。</description>
    </item>
    
    <item>
      <title>10种JavaScript快乐写法</title>
      <link>/posts/07/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:42 +0800</pubDate>
      
      <guid>/posts/07/</guid>
      <description>数组去重 方式一 const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = Array.from(new Set(arr)); // const uniqueArr = [...new Set(arr)]; 方式二 const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = []; arr.forEach((item) =&amp;gt; { // 或者!uniqueArr.includes(item) if (uniqueArr.indexOf(item) === -1) { uniqueArr.push(item); } }); const arr = [ &amp;#34;justin1go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin2go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, &amp;#34;justin3go&amp;#34;, ]; const uniqueArr = arr.filter((item, index) =&amp;gt; { return arr.</description>
    </item>
    
    <item>
      <title>建造者模式</title>
      <link>/posts/06/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:40 +0800</pubDate>
      
      <guid>/posts/06/</guid>
      <description>建造者模式：将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不用的表示。
创建对象的另一种形式 // 创建一位人类 var Human = function (param) { // 技能 this.skill = (param &amp;amp;&amp;amp; param.skill) || &amp;#34;保密&amp;#34;; // 兴趣爱好 this.hobby = (param &amp;amp;&amp;amp; param.hobby) || &amp;#34;保密&amp;#34;; }; // 类人原型方法 Human.prototype = { getSkill: function () { return this.skill; }, getHobby: function () { return this.hobby; }, }; // 实例化姓名类 var Named = function (name) { var that = this; // 构造器 // 构造函数解析姓名的姓与名 (function (name, that) { that.</description>
    </item>
    
    <item>
      <title>抽象工厂模式</title>
      <link>/posts/05/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:37 +0800</pubDate>
      
      <guid>/posts/05/</guid>
      <description>抽象类 是一种声明了但不能使用的类，当你使用的时候就会报错。
// 汽车抽象类，当使用其实例对象的方法时会抛出错误 var Car = function () {}; Car.prototype = { getPrice: function () { return new Error(&amp;#34;抽象方法不能调用&amp;#34;); }, getSpeed: function () { return new Error(&amp;#34;抽象方法不能调用&amp;#34;); }, }; 如上，创建这个 Car 类其实什么都不用做，创建时没有任何属性，然后其原型上方法也不能使用，否则会报错。但在继承上很有用，因为定义了一种类，并定义了该类所必备的方法，如果在子类中没有重写这些方法，那调用的时候就会报错。
抽象工厂模式 直接赋值是无法实现正确的继承关系的。如果直接将子类的原型设置为父类的实例，那么子类的原型对象将直接引用父类的实例对象，这样在修改子类的原型时会直接影响到父类的实例。而使用 F 函数作为中转，可以通过 F 函数的实例来实现子类对父类的继承，同时保持子类和父类的独立性，避免相互影响。这样子类可以自由地修改自己的原型对象，而不会影响到父类或其他子类的实例。因此，使用 F 函数作为中转是为了正确实现继承关系和保持对象的独立性。
// 抽象工厂方法 var VehicleFactory = function (subType, superType) { // 判断抽象工厂中是否有该抽象类 if (typeof VehicleFactory[superType] === &amp;#34;function&amp;#34;) { // 缓存类 function F() {} // 继承父类属性和方法 F.prototype = new VehicleFactory[superType](); // 将子类 constructor 指向子类 superType.</description>
    </item>
    
    <item>
      <title>ES2016到ES2023新特性</title>
      <link>/posts/04/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:35 +0800</pubDate>
      
      <guid>/posts/04/</guid>
      <description>ES2016 Array.prototype.includes() 这个方法用于检查数组是否包含特定元素，如果包含则返回 true，否则返回 false
// 我有一个水果篮子 const fruitBasket = [&amp;#34;apple&amp;#34;, &amp;#34;banana&amp;#34;, &amp;#34;orange&amp;#34;, &amp;#34;grape&amp;#34;]; // 我要检查篮子里是否有橙子 const hasOrange = fruitBasket.includes(&amp;#34;orange&amp;#34;); console.log(hasOrange); // 输出: true // 我还想知道篮子里是否有葡萄 const hasGrape = fruitBasket.includes(&amp;#34;grape&amp;#34;); console.log(hasGrape); // 输出: true // 现在我要检查篮子里是否有西瓜 const hasWatermelon = fruitBasket.includes(&amp;#34;watermelon&amp;#34;); console.log(hasWatermelon); // 输出: false 求幂运算符 求幂运算符： 这是一个新的算术运算符，用于计算一个数的幂
// 我要计算 2 的 3 次幂 const result = 2 ** 3; console.log(result); // 输出: 8 ES2017 Object.values / Object.entries const person = { name: &amp;#34;Alice&amp;#34;, age: 25, city: &amp;#34;New York&amp;#34;, }; const values = Object.</description>
    </item>
    
    <item>
      <title>工厂方法模式</title>
      <link>/posts/03/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:33 +0800</pubDate>
      
      <guid>/posts/03/</guid>
      <description>安全工厂方法 // 安全模式创建的工厂类 var Factory = function (type, content) { if (this instanceof Factory) { var s = new this[type](content); return s; } else { return new Factory(type, content); } }; // 工厂原型中设置创建所有类型数据对象的基类 Factory.prototype = { Java: function (content) { //... }, JavaScript: function (content) { //... }, UI: function (content) { this.content = content; (function (content) { var div = document.createElement(&amp;#34;div&amp;#34;); div.innerHTML = content; div.style.border = &amp;#34;1px solid red&amp;#34;; document.</description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>/posts/02/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:30 +0800</pubDate>
      
      <guid>/posts/02/</guid>
      <description>又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例，主要用来创建用一类对象。
工作中的一次需求 var LoginAlert = function (text) { this.content = text; }; LoginAlert.prototype.show = function () { // 显示警示框 }; var userNameAlert = new LoginAlert(&amp;#34;用户名不能多于 16 个字母或数字&amp;#34;); userNameAlert.show(); 上面的类，如果对于多种场景，就不那么适用了；可能要需要定义多个类。
如果类太多，那么提供一个 // 篮球基类 var Basketball = function () { this.intro = &amp;#34;篮球盛行于美国&amp;#34;; }; Basketball.prototype = { getMember: function () { console.log(&amp;#34;每个队伍需要5名队员&amp;#34;); }, getBallSize: function () { console.log(&amp;#34;篮球很大&amp;#34;); }, }; // 足球基类 var Football = function () { this.intro = &amp;#34;足球在世界范围内很流行&amp;#34;; }; Football.</description>
    </item>
    
    <item>
      <title>面向对象编程</title>
      <link>/posts/01/</link>
      <pubDate>Sun, 27 Aug 2023 22:28:28 +0800</pubDate>
      
      <guid>/posts/01/</guid>
      <description>封装 创建一个类 var Book = function (id, bookname, price) { this.id = id; this.bookname = bookname; this.price = price; }; 也可以通过在类的原型上添加属性和方法 Book.prototype.display = function () { // 展示这本书 }; // 或者 Book.prototype = { display: function () { // 展示这本书 }, }; 实例化使用类 var book = new Book(10, &amp;#34;JavaScript 设计模式&amp;#34;, 50); console.log(book.bookname); 属性与方法封装 var Book = function (id, name, price) { // 私有属性 var num = 1; // 私有方法 function checkId() {} // 特权方法 this.</description>
    </item>
    
  </channel>
</rss>
